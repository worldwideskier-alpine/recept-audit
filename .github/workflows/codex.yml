name: "Codex"

on:
  workflow_dispatch: {}

permissions:
  contents: "write"

defaults:
  run:
    shell: "bash"

jobs:
  generate:
    name: "Generate from specs (full → new branch)"
    runs-on: "ubuntu-24.04"

    env:
      SPEC_ROOT: "spec"
      SPEC_DIRS: "env foundation features tests"
      PROMPT_FILE: "ai/prompt.md"
      PATCH_FILE: "ai/patch.diff"
      FILES_JSON: "ai/files.json"
      OPENAI_MODEL: "gpt-5-codex"
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      OPENAI_BASE_URL: "${{ secrets.OPENAI_BASE_URL }}"
      BRANCH_PREFIX: "codex/autogen"
      MAX_OUT_TOKENS: "12288"
      TEMPERATURE: "0"
      CURL_TIMEOUT: "300"
      CURL_RETRIES: "5"
      CURL_RETRY_DELAY: "5"

    steps:
      - name: "Checkout main"
        uses: "actions/checkout@v4"
        with:
          ref: "main"
          fetch-depth: "1"
          set-safe-directory: "true"

      - name: "Preflight"
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is not set"; exit 1
          fi
          mkdir -p ai
          command -v jq >/dev/null || (sudo apt-get update && sudo apt-get install -y jq)

      - name: "Probe OpenAI API & model"
        id: probe
        run: |
          set -euo pipefail
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
          BASE="${BASE%/}"
          echo "Base endpoint: $BASE"

          mkdir -p ai

          # --- モデル一覧 ---
          m_tmp="$(mktemp)"
          curl -sS -w "\n%{http_code}\n" \
               -H "Authorization: Bearer ${OPENAI_API_KEY}" \
               "$BASE/v1/models" | tee "$m_tmp" >/dev/null
          m_code="$(tail -n1 "$m_tmp")"
          head -n -1 "$m_tmp" > ai/models.json || true
          rm -f "$m_tmp"

          chosen="${OPENAI_MODEL}"
          if [ "$m_code" -lt 300 ] && command -v jq >/dev/null 2>&1; then
            if ! jq -e --arg id "$OPENAI_MODEL" '.data[].id | select(.==$id)' ai/models.json >/dev/null; then
              for alt in codex-mini-latest o4-mini gpt-4.1-mini; do
                if jq -e --arg id "$alt" '.data[].id | select(.==$id)' ai/models.json >/dev/null; then
                  echo "::warning::fallback model selected: $alt"
                  chosen="$alt"
                  break
                fi
              done
            fi
          else
            echo "::warning::/v1/models not available (code=$m_code); skip listing"
          fi

          # --- Responses API 疎通 ---
          r_tmp="$(mktemp)"
          req='{"model":"'"$chosen"'","input":[{"role":"user","content":[{"type":"input_text","text":"ping"}]}],"max_output_tokens":8}'
          curl -sS -w "\n%{http_code}\n" \
               -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
               -d "$req" "$BASE/v1/responses" | tee "$r_tmp" >/dev/null
          r_code="$(tail -n1 "$r_tmp")"
          head -n -1 "$r_tmp" > ai/probe.responses.json || true
          rm -f "$r_tmp"

          api_kind="responses"
          if [ "$r_code" -ge 300 ]; then
            echo "::warning::Responses API returned $r_code; trying Chat Completions"
            c_tmp="$(mktemp)"
            creq='{"model":"'"$chosen"'","max_tokens":8,"messages":[{"role":"system","content":"Reply with OK."},{"role":"user","content":"ping"}]}'
            curl -sS -w "\n%{http_code}\n" \
                 -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                 -d "$creq" "$BASE/v1/chat/completions" | tee "$c_tmp" >/dev/null
            c_code="$(tail -n1 "$c_tmp")"
            head -n -1 "$c_tmp" > ai/probe.chat.json || true
            rm -f "$c_tmp"
            if [ "$c_code" -lt 300 ]; then
              api_kind="chat"
            fi
          fi

          # 後続ステップ用の出力
          echo "base=$BASE"    >> "$GITHUB_OUTPUT"
          echo "model=$chosen" >> "$GITHUB_OUTPUT"
          echo "api=$api_kind" >> "$GITHUB_OUTPUT"

          # 参考ログ
          if [ "$r_code" -ge 300 ] && command -v jq >/dev/null 2>&1; then
            echo "::notice::Responses probe error: $(jq -r '.error?.message // empty' ai/probe.responses.json)"
          fi

      - name: "Compose prompt (FULL from specs)"
        id: compose
        run: |
          set -euo pipefail
          : > "ai/allowed_paths.txt"
          : > "$PROMPT_FILE"

          # ---- 言語ヒント抽出 ----
          LANG_HINT=""
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/features" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E "^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*" "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E "s/.*[:=]\s*//; s/[\",]//g; s/\s+$//;" | tr "A-Z" "a-z")"
              break
            fi
          done
          if [ -z "$LANG_HINT" ] && [ -f "${SPEC_ROOT}/env/policies.md" ]; then
            line="$(grep -i -m1 -E "\b(php|typescript|javascript|node\.js|python|golang|go|ruby|java|c#|\.net)\b" "${SPEC_ROOT}/env/policies.md" || true)"
            if   printf "%s" "$line" | grep -qi "\bphp\b"; then LANG_HINT="php"
            elif printf "%s" "$line" | grep -qiE "\btypescript|javascript|node\.js\b"; then LANG_HINT="typescript"
            elif printf "%s" "$line" | grep -qi "\bpython\b"; then LANG_HINT="python"
            elif printf "%s" "$line" | grep -qiE "\bgolang|\b go \b"; then LANG_HINT="go"
            elif printf "%s" "$line" | grep -qi "\bruby\b"; then LANG_HINT="ruby"
            elif printf "%s" "$line" | grep -qi "\bjava\b"; then LANG_HINT="java"
            elif printf "%s" "$line" | grep -qiE "\bc#|\.net\b"; then LANG_HINT="csharp"
            fi
          fi
          case "${LANG_HINT:-}" in
            php*|composer*|psr*)              LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*)                        LANG_HINT="python" ;;
            go|golang*)                        LANG_HINT="go" ;;
            ruby*)                             LANG_HINT="ruby" ;;
            java*)                             LANG_HINT="java" ;;
            c#|dotnet*|.net*|cs)              LANG_HINT="csharp" ;;
            "" )                               LANG_HINT="auto" ;;
          esac
          echo "Language from specs: ${LANG_HINT}"

          # ---- ALLOWED_PATHS 抽出 ----
          grep -R -n -E "(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+\.[A-Za-z0-9]+)" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" \
            | grep -E "[/A-Za-z0-9_.-]+\.[A-Za-z0-9]+" >> "ai/allowed_paths.txt" || true
          grep -R -h -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)" "$SPEC_ROOT" \
            | grep -o -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)" >> "ai/allowed_paths.txt" || true
          grep -R -h -E "(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" | awk '{gsub(/\/?$/,"/");print}' >> "ai/allowed_paths.txt" || true
          sed -E "s#^\./##; s#//+#/#g" -i "ai/allowed_paths.txt" || true
          LC_ALL=C sort -u "ai/allowed_paths.txt" -o "ai/allowed_paths.txt"

          # ---- プロンプト本体 ----
          {
            printf "# Codex generation prompt\n\n"
            printf "## LANGUAGE (MUST)\n\nlanguage: %s\n" "$LANG_HINT"
            printf "\n## ALLOWED_PATHS (only modify/create under these; NEVER touch ai/)\n\n"
            if [ -s "ai/allowed_paths.txt" ]; then
              while IFS= read -r line; do printf -- "- %s\n" "$line"; done < "ai/allowed_paths.txt"
            else
              case "$LANG_HINT" in
                php)         printf -- "- app.php\n- public/\n- src/\n- tests/\n- composer.json\n" ;;
                typescript)  printf -- "- src/\n- app/\n- package.json\n- tsconfig.json\n- vite.config.*\n" ;;
                python)      printf -- "- src/\n- app/\n- requirements.txt\n- pyproject.toml\n" ;;
                *)           printf -- "- /\n" ;;
              esac
              printf "\nDo NOT modify ai/ directory.\n"
            fi
            printf "\n## Example header (force unified diff)\n\ndiff --git a/app.php b/app.php\n"
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Output ONE Git unified diff (UTF-8). No prose, no code fences.\n"
            printf -- "- MUST start with: diff --git a/<path> b/<path>\n"
            printf -- "- Follow LANGUAGE; respect ALLOWED_PATHS strictly.\n"
            printf -- "- Include real code (no placeholders). If initial attempt fails, still SYNTHESIZE a complete diff that fulfills the specs.\n"
          } >> "$PROMPT_FILE"

          # ---- 仕様書を連結 ----
          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e "s/\r$//" "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

          echo "LANG_HINT=${LANG_HINT}" >> "$GITHUB_OUTPUT"

      - name: "Generate unified diff, commit to new branch, push"
        id: gen
        run: |
          set -euo pipefail

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          MODEL="${{ steps.probe.outputs.model || env.OPENAI_MODEL }}"
          BASE="${{ steps.probe.outputs.base || env.OPENAI_BASE_URL }}"
          BASE="${BASE:-https://api.openai.com}"
          BASE="${BASE%/}"

          API_KIND="${{ steps.probe.outputs.api || 'responses' }}"
          if [ "$API_KIND" = "chat" ]; then
            ENDPOINT="${BASE}/v1/chat/completions"
          else
            ENDPOINT="${BASE}/v1/responses"
          fi

          BRANCH_NAME="${BRANCH_PREFIX}-${GITHUB_RUN_ID}"
          git checkout -b "${BRANCH_NAME}"

          # ---- 抽出 jq（多系統に耐える）----
          cat > "ai/extract.jq" << 'JQ'
          def texts:
            (try(.output_text) // empty),
            (try(.output[]?.content[]?.text) // empty),
            (try(.choices[0].message.content) // empty),
            (try(.choices[0].text) // empty);
          [ texts ] | map(select(type=="string" and . != "")) | first // ""
          JQ

          # リクエスト生成：API 種類で JSON を切替
          gen_req() {
            local system_text="$1"
            local user_file="$2"
            local out_file="$3"
            if [ "$API_KIND" = "chat" ]; then
              jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --arg temp "$TEMPERATURE" \
                    --arg sys "$system_text" --rawfile prompt "$user_file" \
                '{ "model":$model, "max_tokens":($max|tonumber), "temperature":($temp|tonumber),
                   "messages":[{"role":"system","content":$sys},{"role":"user","content":$prompt}] }' > "$out_file"
            else
              jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --arg temp "$TEMPERATURE" \
                    --arg sys "$system_text" --rawfile prompt "$user_file" \
                '{ "model":$model, "max_output_tokens":($max|tonumber), "temperature":($temp|tonumber),
                   "input":[ {"role":"system","content":[{"type":"input_text","text":$sys}]},
                             {"role":"user","content":[{"type":"input_text","text":$prompt}]} ] }' > "$out_file"
            fi
          }

          call_api_with_retry() {
            # $1: request.json  $2: response.json
            local req="$1"; local out="$2"
            local attempt=1
            while [ $attempt -le 3 ]; do
              local tmp="$(mktemp)"
              curl -sS --connect-timeout 30 --max-time "$CURL_TIMEOUT" \
                   --retry "$CURL_RETRIES" --retry-all-errors --retry-delay "$CURL_RETRY_DELAY" \
                   -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                   -w "\n%{http_code}\n" -d @"$req" "$ENDPOINT" | tee "$tmp" >/dev/null
              local status; status="$(tail -n1 "$tmp")"
              head -n -1 "$tmp" > "$out"; rm -f "$tmp"

              if [ "$status" -lt 300 ]; then
                return 0
              fi

              # エラーメッセージ可視化（可能なら）
              if command -v jq >/dev/null 2>&1; then
                echo "::notice::API error $status: $(jq -r '.error?.message // empty' "$out")"
              fi

              case "$status" in
                408|429|500|502|503|504)
                  echo "::warning::OpenAI transient ${status}; shrinking tokens and retrying (attempt $((attempt+1)))"
                  MAX_OUT_TOKENS=$(( MAX_OUT_TOKENS / 2 ))
                  [ "$MAX_OUT_TOKENS" -lt 4096 ] && MAX_OUT_TOKENS=4096
                  attempt=$((attempt+1))
                  return 1
                  ;;
                400)
                  # 形式不一致の可能性 → もう一方の API へ切替して 1 回だけ再送
                  if [ "$API_KIND" = "responses" ]; then
                    echo "::warning::400 with Responses; switching to Chat Completions"
                    API_KIND="chat"; ENDPOINT="${BASE}/v1/chat/completions"
                  else
                    echo "::warning::400 with Chat; switching to Responses API"
                    API_KIND="responses"; ENDPOINT="${BASE}/v1/responses"
                  fi
                  return 1
                  ;;
                *)
                  echo "::error::OpenAI fatal ${status}"
                  return 2
                  ;;
              esac
            done
            echo "::error::OpenAI repeated transient failures"; return 2
          }

          # ---- 1st request（diff 専用）----
          system1=$'Output ONLY a Git unified diff.\nMUST start with: diff --git a/<path> b/<path>\nNo prose or fences.'
          gen_req "$system1" "$PROMPT_FILE" "ai/request.json"

          # 送信＆必要に応じて API 種切替／token 縮小
          for _ in 1 2 3; do
            if call_api_with_retry "ai/request.json" "ai/response.json"; then
              break
            else
              gen_req "$system1" "$PROMPT_FILE" "ai/request.json"
            fi
          done

          jq -r -f "ai/extract.jq" "ai/response.json" > "ai/out.txt"
          # フェンス等を除去
          sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i "ai/out.txt" || true
          # パッチ抽出（BOM/空行/Index:/*** も許容）
          awk 'f||/^(diff --git|--- a\/|\*\*\* |Index: )/{f=1; print}' "ai/out.txt" > "$PATCH_FILE" || true

          is_unified=0
          if grep -Eq "^(diff --git|--- (a\/|\/dev\/null)|Index: |\*\*\* )" "$PATCH_FILE" \
             && grep -Eq "(\+\+\+ b\/|^diff --git|^--- b\/)" "$PATCH_FILE"; then
            is_unified=1
          fi

          # ---- repair（2回まで、元プロンプト再投入）----
          if [ "$is_unified" -ne 1 ]; then
            echo "::warning::first attempt not a unified diff; repairing"
            system2=$'Output ONLY a Git unified diff.\nMUST start with: diff --git a/<path> b/<path>\nNo prose or fences.'
            for i in 1 2; do
              gen_req "$system2" "$PROMPT_FILE" "ai/request.repair.json"
              for _ in 1 2 3; do
                if call_api_with_retry "ai/request.repair.json" "ai/response.repair.json"; then
                  break
                else
                  gen_req "$system2" "$PROMPT_FILE" "ai/request.repair.json"
                fi
              done
              jq -r -f "ai/extract.jq" "ai/response.repair.json" > "ai/out.repair.txt"
              sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i "ai/out.repair.txt" || true
              awk 'f||/^(diff --git|--- a\/|\*\*\* |Index: )/{f=1; print}' "ai/out.repair.txt" > "$PATCH_FILE" || true
              if grep -Eq "^(diff --git|--- (a\/|\/dev\/null)|Index: |\*\*\* )" "$PATCH_FILE" \
                 && grep -Eq "(\+\+\+ b\/|^diff --git|^--- b\/)" "$PATCH_FILE"; then
                is_unified=1; break
              fi
            done
          fi

          # ---- diff 経路適用 ----
          if [ "$is_unified" -eq 1 ]; then
            if git apply --check "$PATCH_FILE"; then
              git apply --index --whitespace=fix "$PATCH_FILE"
            else
              echo "::warning::git apply check failed; attempting 3-way merge"
              git apply --3way --index --whitespace=fix "$PATCH_FILE" || true
            fi
          fi

          # ---- フォールバック: files-JSON で必ず生成 ----
          if ! git diff --cached --name-only | grep -q "."; then
            echo "::warning::No staged changes after diff path; switching to files-JSON fallback"

            system3=$'Output ONLY a compact JSON with exact key `files`: [{ "path": "relative/path", "content": "UTF-8 file content" }, ...]. No prose, no markdown, no trailing text.'
            gen_req "$system3" "$PROMPT_FILE" "ai/request.files.json"
            for _ in 1 2 3; do
              if call_api_with_retry "ai/request.files.json" "ai/response.files.json"; then
                break
              else
                gen_req "$system3" "$PROMPT_FILE" "ai/request.files.json"
              fi
            done

            jq 'try(.files) // empty' "ai/response.files.json" > "$FILES_JSON"
            if [ ! -s "$FILES_JSON" ] || ! jq -e 'type=="array" and length>0 and all(.[]; has("path") and has("content"))' "$FILES_JSON" >/dev/null; then
              echo "::error::Model did not return valid files JSON"; exit 7
            fi

            allow_all=0
            if [ -s "ai/allowed_paths.txt" ]; then
              mapfile -t ALLOWED < "ai/allowed_paths.txt"
            else
              allow_all=1
            fi

            jq -r '.[] | @base64' "$FILES_JSON" | while read -r row; do
              _jq(){ echo "$row" | base64 -d | jq -r "$1"; }
              p="$(_jq '.path' )"; c="$(_jq '.content')"
              if printf "%s" "$p" | grep -q '^ai/'; then
                echo "::warning::skip ai/ path: $p"; continue
              fi
              ok="$allow_all"
              if [ "$allow_all" -ne 1 ]; then
                for pat in "${ALLOWED[@]}"; do
                  if [ "${p#"$pat"}" != "$p" ] || [ "$p" = "$pat" ]; then ok=1; break; fi
                done
              fi
              if [ "$ok" -ne 1 ]; then
                echo "::warning::skip (not allowed): $p"; continue
              fi
              mkdir -p "$(dirname "$p")"
              printf "%s" "$c" > "$p"
              git add "$p"
            done
          fi

          if ! git diff --cached --name-only | grep -q "."; then
            echo "::error::No changes staged after all paths"; exit 6
          fi

          git commit -m "codex(full): generated from specs via ${MODEL}"
          git push origin "HEAD:${BRANCH_NAME}"

          echo "branch=${BRANCH_NAME}" >> "$GITHUB_OUTPUT"
          echo "Generated branch: ${BRANCH_NAME}"

      - name: "Upload AI artifacts"
        uses: "actions/upload-artifact@v4"
        with:
          name: "ai-artifacts"
          if-no-files-found: "ignore"
          path: |
            ai/models.json
            ai/probe.responses.json
            ai/probe.chat.json
            ai/prompt.md
            ai/allowed_paths.txt
            ai/request.json
            ai/response.json
            ai/out.txt
            ai/request.repair.json
            ai/response.repair.json
            ai/out.repair.txt
            ai/patch.diff
            ai/request.files.json
            ai/response.files.json
            ai/files.json
