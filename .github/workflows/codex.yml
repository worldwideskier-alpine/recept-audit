name: "Codex"

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate:
    runs-on: ubuntu-24.04
    env:
      SPEC_ROOT: "spec"
      SPEC_DIRS: "env foundation features tests"
      PROMPT_FILE: "ai/prompt.md"
      FILES_JSON: "ai/files.json"
      PATCH_FILE: "ai/patch.diff"
      PLAN_JSON: "ai/plan.json"
      OPENAI_MODEL: "gpt-5-codex"
      OPENAI_BASE_URL: ""
      BRANCH_PREFIX: "codex/autogen"
      MAX_OUT_TOKENS: "12288"
      CURL_TIMEOUT: "300"
      CURL_RETRIES: "5"
      CURL_RETRY_DELAY: "5"
      MAX_PASSES: "3"
      BATCH_SIZE: "12"
      PLAN_MAX_FILES: "120"
      # 必須: リポジトリの Secrets に OPENAI_API_KEY を設定してください。
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
        with:
          ref: "main"
          fetch-depth: 1

      - name: "Preflight & deps"
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is not set"; exit 1
          fi
          mkdir -p ai
          command -v jq >/dev/null || (sudo apt-get update -y && sudo apt-get install -y jq coreutils)

      - name: "Detect language & build allowed paths"
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          : > "ai/allowed_paths.txt"
          : > "$PROMPT_FILE"

          LANG_HINT=""
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/features" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E "^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*" "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E "s/.*[:=]\s*//; s/[\",]//g; s/\s+$//;" | tr "A-Z" "a-z")"; break
            fi
          done
          case "${LANG_HINT:-}" in
            php*|composer*|psr*) LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*)          LANG_HINT="python" ;;
            go|golang*)          LANG_HINT="go" ;;
            ruby*)               LANG_HINT="ruby" ;;
            java*)               LANG_HINT="java" ;;
            c#|dotnet*|.net*|cs) LANG_HINT="csharp" ;;
            "" )                 LANG_HINT="auto" ;;
          esac
          if [ "$LANG_HINT" = "auto" ]; then
            if   find . -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) -print -quit | grep -q .; then LANG_HINT="typescript"
            elif find . -type f -name "*.py" -print -quit | grep -q .; then LANG_HINT="python"
            elif find . -type f -name "*.php" -print -quit | grep -q . || [ -f composer.json ]; then LANG_HINT="php"
            elif [ -f go.mod ]; then LANG_HINT="go"
            else LANG_HINT="typescript"
            fi
          fi
          echo "lang_hint=$LANG_HINT" >> "$GITHUB_OUTPUT"

          # allowlist 候補を spec から抽出
          grep -R -n -E "(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+(\.[A-Za-z0-9]+)?)" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" >> "ai/allowed_paths.txt" || true
          grep -R -h -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml|env|conf|cfg|sh|htaccess)" "$SPEC_ROOT" \
            | grep -o -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml|env|conf|cfg|sh|htaccess)" >> "ai/allowed_paths.txt" || true
          grep -R -h -E "(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" | awk '{gsub(/\/?$/,"/");print}' >> "ai/allowed_paths.txt" || true

          if ! grep -Eq '\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql)$' ai/allowed_paths.txt; then
            case "$LANG_HINT" in
              typescript) printf "%s\n" "src/" "app/" "lib/" "package.json" "tsconfig.json" >> ai/allowed_paths.txt ;;
              python)     printf "%s\n" "src/" "app/" "pyproject.toml" "requirements.txt" >> ai/allowed_paths.txt ;;
              php)        printf "%s\n" "src/" "app/" "public/" "composer.json" >> ai/allowed_paths.txt ;;
              go)         printf "%s\n" "cmd/" "internal/" "pkg/" "go.mod" >> ai/allowed_paths.txt ;;
            esac
          fi

          sed -E "s#^\./##; s#//+#/#g" -i "ai/allowed_paths.txt" || true
          LC_ALL=C sort -u -o ai/allowed_paths.txt ai/allowed_paths.txt

          {
            printf "# Codex generation prompt\n\n"
            printf "## LANGUAGE (MUST)\n\nlanguage: %s\n" "$LANG_HINT"
            printf "\n## ALLOWED_PATHS (only modify/create under these; NEVER touch ai/)\n\n"
            while IFS= read -r line; do printf -- "- %s\n" "$line"; done < "ai/allowed_paths.txt"
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Use ONLY the tool 'emit_files' to return files. No prose.\n"
            printf -- "- Implement the SPEC as runnable APPLICATION CODE and TESTS under ALLOWED_PATHS.\n"
            printf -- "- Do NOT create compliance/policy/README/meta documents.\n"
            printf -- "- Include real code (no placeholders).\n"
          } >> "$PROMPT_FILE"

          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e "s/\r$//" "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

      - name: "Prepare jq filters"
        shell: bash
        run: |
          set -euo pipefail
          {
            printf 'def to_text(x):\n'
            printf '  if x==null then ""\n'
            printf '  elif (x|type)=="string" then x\n'
            printf '  elif (x|type)=="array" then (x|map(tostring)|join("\\n"))\n'
            printf '  elif (x|type)=="object" and (x|has("code")) then to_text(x.code)\n'
            printf '  elif (x|type)=="object" and (x|has("text")) then to_text(x.text)\n'
            printf '  else tostring end;\n'
            printf 'def pick_files:\n'
            printf '  if (type=="object") and has("files") and (.files|type)=="array" then (.files)\n'
            printf '  elif (type=="array") then .\n'
            printf '  elif (type=="object") and (has("path") and has("content")) then [ {path:.path, content:.content} ]\n'
            printf '  elif (type=="object") then ( [ .[] ] | map(pick_files) | add? ) // []\n'
            printf '  else [] end;\n'
            printf 'pick_files\n'
            printf '| map({ path: ( ( .path // .file // .name // .filename // "" ) | tostring ),\n'
            printf '        content: to_text( ( .content // .code // .text // "" ) ) })\n'
          } > "ai/normalize.jq"

      - name: "Create working branch"
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          BRANCH_NAME="${BRANCH_PREFIX}-${GITHUB_RUN_ID}"
          git checkout -b "${BRANCH_NAME}"

      - name: "Generate files via tools(function calling)"
        env:
          ENDPOINT_KIND: "chat"
        shell: bash
        run: |
          set -euo pipefail
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
          ENDPOINT="${BASE%/}/v1/chat/completions"

          # Tool schema (emit_files)
          tools_json=$(
            jq -n '[
              {
                "type":"function",
                "function":{
                  "name":"emit_files",
                  "description":"Create or modify project files. Return all files to write.",
                  "parameters":{
                    "type":"object",
                    "additionalProperties": false,
                    "required":["files"],
                    "properties":{
                      "files":{
                        "type":"array",
                        "items":{
                          "type":"object",
                          "additionalProperties": false,
                          "required":["path","content"],
                          "properties":{
                            "path":{"type":"string","minLength":1},
                            "content":{"type":"string"}
                          }
                        }
                      }
                    }
                  }
                }
              }
            ]'
          )

          # Build request (NO temperature)
          jq -n \
            --arg model "$OPENAI_MODEL" \
            --rawfile prompt "$PROMPT_FILE" \
            --arg tools "$tools_json" \
          '{
            "model": $model,
            "messages": [
              {"role":"system","content":
                "You MUST call the tool emit_files only. Do not write prose or code fences. \
Implement runnable application code and tests strictly under ALLOWED_PATHS. \
Skip compliance/policy/README/meta docs. Use real code with no placeholders."
              },
              {"role":"user","content": $prompt}
            ],
            "tools": ($tools|fromjson),
            "tool_choice": {"type":"function","function":{"name":"emit_files"}}
          }' > ai/request.tools.json

          call_api_with_retry() {
            local req="$1"; local out="$2"; local attempt=1
            while [ $attempt -le 3 ]; do
              local tmp="$(mktemp)"
              curl -sS --connect-timeout 30 --max-time "$CURL_TIMEOUT" \
                   --retry "$CURL_RETRIES" --retry-all-errors --retry-delay "$CURL_RETRY_DELAY" \
                   -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                   -H "Content-Type: application/json" \
                   -w "\n%{http_code}\n" -d @"$req" "$ENDPOINT" | tee "$tmp" >/dev/null
              local status; status="$(tail -n1 "$tmp")"
              head -n -1 "$tmp" > "$out"; rm -f "$tmp"
              [ "$status" -lt 300 ] && return 0
              local msg=""; command -v jq >/dev/null 2>&1 && msg="$(jq -r '.error?.message // empty' "$out")"
              [ -n "$msg" ] && echo "::notice::API error $status: $msg"
              case "$status" in
                408|429|500|502|503|504) echo "::warning::transient ${status}; shrinking tokens and retrying"; MAX_OUT_TOKENS=$(( MAX_OUT_TOKENS / 2 )); [ "$MAX_OUT_TOKENS" -lt 4096 ] && MAX_OUT_TOKENS=4096; attempt=$((attempt+1)); continue ;;
                400) echo "::error::fatal 400 for this model/endpoint"; return 2 ;;
                *) echo "::error::fatal ${status}"; return 2 ;;
              esac
            done
            return 2
          }

          # Call API
          call_api_with_retry "ai/request.tools.json" "ai/response.json"

          # Extract tool arguments (strict JSON string)
          jq -r '
            [ .choices[]? // empty
              | .message?.tool_calls[]?
              | select(.function?.name == "emit_files")
              | .function.arguments
            ] | first // ""
          ' ai/response.json > ai/out.files.txt

          if ! jq -e . ai/out.files.txt >/dev/null 2>&1; then
            echo "::group::raw arguments (first 2KB)"; head -c 2048 ai/out.files.txt | sed 's/^/RAW: /'; echo "::endgroup::"
            echo "::error::Invalid tool arguments JSON"; exit 7
          fi

          # Normalize -> array of {path,content}
          jq -c -f "ai/normalize.jq" "ai/out.files.txt" > "$FILES_JSON"
          if [ ! -s "$FILES_JSON" ] || ! jq -e 'type=="array" and length>0 and all(.[]; has("path") and has("content"))' "$FILES_JSON" >/dev/null; then
            echo "::error::Model did not return valid files JSON"; exit 7
          fi

          # Apply allowlist and write files
          allow_all=0
          if [ -s "ai/allowed_paths.txt" ]; then mapfile -t ALLOWED < "ai/allowed_paths.txt"; else allow_all=1; fi

          jq -r '.[] | @base64' "$FILES_JSON" | while read -r row; do
            _jq(){ echo "$row" | base64 -d | jq -r "$1"; }
            p="$(_jq '.path')"; c="$(_jq '.content')"
            case "$p" in ai/*) echo "::warning::skip ai/: $p"; continue ;; esac
            if printf "%s" "$p" | grep -qiE '(COMPLIANCE|SECURITY|CODE_OF_CONDUCT|CONTRIBUTING|README)\.(md|txt|json)$'; then
              echo "::warning::skip non-code doc: $p"; continue
            fi
            ok="$allow_all"
            if [ "$allow_all" -ne 1 ]; then
              for pat in "${ALLOWED[@]}"; do
                if [ "${p#"$pat"}" != "$p" ] || [ "$p" = "$pat" ]; then ok=1; break; fi
              done
            fi
            [ "$ok" -ne 1 ] && { echo "::warning::skip (not allowed): $p"; continue; }
            mkdir -p "$(dirname "$p")"
            printf "%s" "$c" > "$p"
            git add "$p"
          done

          if ! git diff --cached --name-only | grep -q "."; then
            echo "::error::No changes staged after all paths"; exit 6
          fi

          if ! git diff --cached --name-only | grep -E '\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|sh|conf|cfg)$|(^|/)\.htaccess$|(^|/)Dockerfile$|(^|/)Makefile$' >/dev/null; then
            echo "::error::No code files staged (only non-code docs). Aborting."; exit 6
          fi

          git commit -m "codex(init): seed from specs via ${OPENAI_MODEL}"

      - name: "Upload artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: "ai-artifacts-${{ github.run_id }}"
          path: |
            ai/**
            !**/*.tmp
          if-no-files-found: warn
          compression-level: 6
          overwrite: false
          include-hidden-files: false

      - name: "Summary"
        shell: bash
        run: |
          echo "Branch created: $(git branch --show-current)"
          echo "Seed files:"
          git show --name-only --pretty="" HEAD || true
