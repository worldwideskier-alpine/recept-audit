name: "Codex"

on:
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  generate:
    name: "Generate from specs"
    runs-on: "ubuntu-24.04"

    env:
      SPEC_ROOT: "spec"
      SPEC_DIRS: "env features foundation fountation tests"
      PROMPT_FILE: "ai/prompt.md"
      PATCH_FILE: "ai/patch.diff"
      GEN_OUTPUT_DIR: "generated"
      OPENAI_MODEL: "gpt-5-codex"
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      OPENAI_BASE_URL: "${{ secrets.OPENAI_BASE_URL }}"

    steps:
      - name: "Checkout"
        uses: "actions/checkout@v4"
        with:
          fetch-depth: "1"
          set-safe-directory: true

      - name: "Preflight"
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is not set"
            exit 1
          fi
          mkdir -p "ai" "$GEN_OUTPUT_DIR"

      - name: "Compose prompt from specs (full only, detect language, allowed paths)"
        id: "compose"
        shell: bash
        run: |
          set -euo pipefail

          : > "$PROMPT_FILE"
          : > "ai/allowed_paths.txt"

          # --- Language detection (free-text aware) ---
          LANG_HINT=""
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E '^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*' "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E 's/.*[:=]\s*//; s/[",]//g; s/\s+$//;' | tr 'A-Z' 'a-z')"
              break
            fi
          done

          if [ -z "$LANG_HINT" ]; then
            t="$(grep -R -h -i -E '\b(php|typescript|javascript|node\.js|python|golang|go|ruby|java|c#|\.net)\b' \
                 "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" 2>/dev/null | head -n1 || true)"
            case "$t" in
              *php* ) LANG_HINT="php" ;;
              *typescript*|*javascript*|*node.js*|*"node "* ) LANG_HINT="typescript" ;;
              *python* ) LANG_HINT="python" ;;
              *golang*|*" go "*|go[^a-zA-Z]* ) LANG_HINT="go" ;;
              *ruby* ) LANG_HINT="ruby" ;;
              *java* ) LANG_HINT="java" ;;
              *c#*|*.net* ) LANG_HINT="csharp" ;;
            esac
          fi

          case "${LANG_HINT:-}" in
            php*|composer*|psr*)              LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*)                        LANG_HINT="python" ;;
            go|golang*)                        LANG_HINT="go" ;;
            ruby*)                             LANG_HINT="ruby" ;;
            java*)                             LANG_HINT="java" ;;
            c#|dotnet*|.net*|cs)              LANG_HINT="csharp" ;;
            "" )                               LANG_HINT="auto" ;;
          esac

          if [ "$LANG_HINT" = "auto" ]; then
            echo "::warning::Language not found in environment specs; using 'auto'."
          else
            echo "Language from env-spec: ${LANG_HINT}"
          fi

          # --- ALLOWED_PATHS (from specs) ---
          grep -R -n -E '(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+\.[A-Za-z0-9]+)' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\''"]//g' \
            | grep -E '[/A-Za-z0-9_.-]+\.[A-Za-z0-9]+' >> "ai/allowed_paths.txt" || true

          grep -R -h -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)' "$SPEC_ROOT" \
            | grep -o -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)' \
            >> "ai/allowed_paths.txt" || true

          grep -R -h -E '(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\''"]//g' | awk '{gsub(/\/?$/,"/");print}' >> "ai/allowed_paths.txt" || true

          sed -E 's#^\./##; s#//+#/#g' -i "ai/allowed_paths.txt" || true
          LC_ALL=C sort -u "ai/allowed_paths.txt" -o "ai/allowed_paths.txt"

          # --- Default scaffold paths when not specified (PHP biased per env spec) ---
          if [ ! -s "ai/allowed_paths.txt" ] || [ "$LANG_HINT" = "php" ]; then
            printf "%s\n" \
              "composer.json" \
              "public/.htaccess" \
              "public/index.php" \
              "src/Bootstrap.php" \
              "src/Router.php" \
              "src/Http/HttpClient.php" \
              "src/Controller/HomeController.php" \
              "tests/HttpClientTest.php" \
              "phpunit.xml" \
              >> "ai/allowed_paths.txt"
          fi
          LC_ALL=C sort -u "ai/allowed_paths.txt" -o "ai/allowed_paths.txt"

          # --- Prompt (full) ---
          printf "%s\n" "# Codex generation prompt" >> "$PROMPT_FILE"
          printf "\n## LANGUAGE (MUST)\n\n" >> "$PROMPT_FILE"
          printf "language: %s\n" "$LANG_HINT" >> "$PROMPT_FILE"

          printf "\n## ALLOWED_PATHS (only modify/create under these)\n\n" >> "$PROMPT_FILE"
          while IFS= read -r line; do
            printf -- "- %s\n" "$line" >> "$PROMPT_FILE"
          done < "ai/allowed_paths.txt"

          # Concatenate ALL spec files (full mode only)
          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e 's/\r$//' "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

          {
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Return ONE unified diff (UTF-8), repository-rooted; no prose, no code fences.\n"
            printf -- "- Modify/create files **only** under ALLOWED_PATHS. When ALLOWED_PATHS matches the default PHP scaffold above, you MUST create that scaffold at minimum.\n"
            printf -- "- PHP runtime: 8.3 (CLI/CGI). No framework assumption. PSR compliance optional.\n"
            printf -- "- Web: Apache + mod_rewrite; AllowOverride FileInfo+.\n"
            printf -- "- HTTP client: use cURL only (disallow file_get_contents for HTTP).\n"
          } >> "$PROMPT_FILE"

          echo "LANG_HINT=${LANG_HINT}" >> "$GITHUB_OUTPUT"

      - name: "Call OpenAI (gpt-5-codex / Responses API)"
        shell: bash
        run: |
          set -euo pipefail

          is_patch(){ grep -Eq '^(diff --git|--- a/)' "$1" && grep -Eq '(^\+\+\+ b/|^diff --git)' "$1"; }

          MODEL="${OPENAI_MODEL}"
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
          ENDPOINT="${BASE%/}/v1/responses"
          echo "Using model: $MODEL"
          echo "Base: $BASE"

          SYSTEM_CONTRACT="You output only a unified diff. Follow LANGUAGE and ALLOWED_PATHS strictly; do not create files outside ALLOWED_PATHS. If ALLOWED_PATHS equals the default PHP scaffold, create that scaffold minimally."

          jq -n --arg model "$MODEL" --arg sys "$SYSTEM_CONTRACT" --rawfile prompt "$PROMPT_FILE" \
            '{ model:$model, max_output_tokens:4096,
               input:[ {role:"system",content:[{type:"input_text",text:$sys}]},
                       {role:"user",  content:[{type:"input_text",text:$prompt}]} ] }' > "ai/request.json"

          resp_with_code="$(mktemp)"
          curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
               -w "\n%{http_code}\n" -d @ai/request.json "$ENDPOINT" \
               | tee "$resp_with_code" >/dev/null
          status="$(tail -n1 "$resp_with_code")"
          head -n -1 "$resp_with_code" > "ai/response.json"
          rm -f "$resp_with_code"
          [ "$status" -lt 300 ] || { echo "::error::OpenAI error ${status}"; exit 3; }

          EXTRACT='[
            .output_text,
            ( try(.output
                 | (if type=="array" then . else [] end)
                 | map( if has("content")
                          then (.content
                                | (if type=="array" then map(.text // .string // .content // "") else . end)
                                | (if type=="array" then join("") else (. // "") end))
                          else (.text // .content // "") end)
                 | join("")) catch empty )
          ] | map(select(type=="string" and . != "")) | .[0] // ""'

          jq -r "$EXTRACT" "ai/response.json" > "ai/out.txt"
          sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i "ai/out.txt" || true
          awk 'f||/^(diff --git|--- a\/)/{f=1; print}' "ai/out.txt" > "$PATCH_FILE" || true

          if ! is_patch "$PATCH_FILE"; then
            echo "::warning::first attempt not a unified diff; repairing once"
            head -c 15000 "ai/out.txt" > "ai/out.trim.txt" || true
            REPAIR_SYS="If text contains a diff, extract ONLY that diff. Otherwise, synthesize a single unified diff that creates the default PHP scaffold exactly under ALLOWED_PATHS."
            jq -n --arg model "$MODEL" --arg sys "$REPAIR_SYS" --rawfile prev "ai/out.trim.txt" \
              '{ model:$model, max_output_tokens:4096,
                 input:[ {role:"system",content:[{type:"input_text",text:$sys}]},
                         {role:"user",content:[{type:"input_text",text:$prev}]} ] }' > "ai/request.repair.json"
            resp_with_code="$(mktemp)"
            curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                 -w "\n%{http_code}\n" -d @ai/request.repair.json "$ENDPOINT" \
                 | tee "$resp_with_code" >/dev/null
            rstatus="$(tail -n1 "$resp_with_code")"
            head -n -1 "$resp_with_code" > "ai/response.repair.json"
            rm -f "$resp_with_code"
            [ "$rstatus" -lt 300 ] || { echo "::error::repair call error ${rstatus}"; exit 3; }
            jq -r "$EXTRACT" "ai/response.repair.json" > "ai/out.repair.txt"
            sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i "ai/out.repair.txt" || true
            awk 'f||/^(diff --git|--- a\/)/{f=1; print}' "ai/out.repair.txt" > "$PATCH_FILE" || true
          fi

          if ! ( grep -Eq '^(diff --git|--- a/)' "$PATCH_FILE" && grep -Eq '(^\+\+\+ b/|^diff --git)' "$PATCH_FILE" ); then
            echo "::warning::model did not return a unified diff; continuing to local scaffold fallback"
            : > "$PATCH_FILE"
          fi
          echo "patch prepared"

      - name: "Apply patch (no diff-mode, ensure generation)"
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if [ -s "$PATCH_FILE" ] && git apply --check "$PATCH_FILE"; then
            git apply --index --whitespace=fix "$PATCH_FILE"
          elif [ -s "$PATCH_FILE" ]; then
            echo "::warning::git apply check failed; attempting 3-way merge apply"
            git apply --3way --index --whitespace=fix "$PATCH_FILE" || true
          fi

          # If still nothing staged, create a minimal PHP scaffold LOCALLY (no heredoc)
          if ! git diff --cached --name-only | grep -q '.'; then
            echo "No staged changes from model; creating local PHP scaffold"
            mkdir -p "public" "src/Controller" "src/Http" "tests"

            # composer.json
            printf "%s\n" \
              "{" \
              "  \"name\": \"app/recept-audit\"," \
              "  \"type\": \"project\"," \
              "  \"require\": {" \
              "    \"php\": \"^8.3\"" \
              "  }," \
              "  \"autoload\": {" \
              "    \"psr-4\": {\"App\\\\\": \"src/\"}" \
              "  }" \
              "}" \
              > "composer.json"

            # public/.htaccess
            printf "%s\n" \
              "RewriteEngine On" \
              "RewriteBase /" \
              "RewriteCond %{REQUEST_FILENAME} !-f" \
              "RewriteCond %{REQUEST_FILENAME} !-d" \
              "RewriteRule ^ index.php [L]" \
              > "public/.htaccess"

            # public/index.php
            printf "%s\n" \
              "<?php" \
              "declare(strict_types=1);" \
              "require __DIR__ . '/../vendor/autoload.php';" \
              "use App\\Router;" \
              "\$router = new Router();" \
              "echo \$router->dispatch(\$_SERVER['REQUEST_METHOD'] ?? 'GET', \$_SERVER['REQUEST_URI'] ?? '/');" \
              > "public/index.php"

            # src/Bootstrap.php
            printf "%s\n" \
              "<?php" \
              "declare(strict_types=1);" \
              "namespace App;" \
              "final class Bootstrap { public static function version(): string { return '0.1.0'; } }" \
              > "src/Bootstrap.php"

            # src/Router.php
            printf "%s\n" \
              "<?php" \
              "declare(strict_types=1);" \
              "namespace App;" \
              "use App\\Controller\\HomeController;" \
              "final class Router {" \
              "  public function dispatch(string \$method, string \$uri): string {" \
              "    \$path = parse_url(\$uri, PHP_URL_PATH) ?: '/';" \
              "    if (\$method === 'GET' && \$path === '/') { return (new HomeController())->index(); }" \
              "    http_response_code(404);" \
              "    return 'Not Found';" \
              "  }" \
              "}" \
              > "src/Router.php"

            # src/Http/HttpClient.php (cURL only)
            printf "%s\n" \
              "<?php" \
              "declare(strict_types=1);" \
              "namespace App\\Http;" \
              "final class HttpClient {" \
              "  public function get(string \$url, array \$headers = []): string {" \
              "    \$ch = curl_init(\$url);" \
              "    curl_setopt_array(\$ch, [" \
              "      CURLOPT_RETURNTRANSFER => true," \
              "      CURLOPT_FOLLOWLOCATION => true," \
              "      CURLOPT_HTTPHEADER => \$headers" \
              "    ]);" \
              "    \$res = curl_exec(\$ch);" \
              "    if (\$res === false) { throw new \\RuntimeException('cURL error: '.curl_error(\$ch)); }" \
              "    curl_close(\$ch);" \
              "    return (string)\$res;" \
              "  }" \
              "}" \
              > "src/Http/HttpClient.php"

            # src/Controller/HomeController.php
            printf "%s\n" \
              "<?php" \
              "declare(strict_types=1);" \
              "namespace App\\Controller;" \
              "use App\\Bootstrap;" \
              "final class HomeController {" \
              "  public function index(): string {" \
              "    header('Content-Type: application/json');" \
              "    return json_encode(['app' => 'recept-audit', 'version' => Bootstrap::version()], JSON_UNESCAPED_SLASHES);" \
              "  }" \
              "}" \
              > "src/Controller/HomeController.php"

            # phpunit.xml
            printf "%s\n" \
              "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" \
              "<phpunit bootstrap=\"vendor/autoload.php\" colors=\"true\">" \
              "  <testsuites><testsuite name=\"unit\"><directory>tests</directory></testsuite></testsuites>" \
              "</phpunit>" \
              > "phpunit.xml"

            # tests/HttpClientTest.php
            printf "%s\n" \
              "<?php" \
              "declare(strict_types=1);" \
              "use PHPUnit\\Framework\\TestCase;" \
              "final class HttpClientTest extends TestCase {" \
              "  public function testDummy(): void { \$this->assertTrue(true); }" \
              "}" \
              > "tests/HttpClientTest.php"

            git add -A
          fi

          git status --porcelain || true

      - name: "Upload AI artifacts"
        uses: "actions/upload-artifact@v4"
        with:
          name: "ai-artifacts"
          if-no-files-found: "ignore"
          path: |
            ai/prompt.md
            ai/allowed_paths.txt
            ai/request.json
            ai/response.json
            ai/out.txt
            ai/request.repair.json
            ai/response.repair.json
            ai/out.repair.txt
            ai/patch.diff

      - name: "Create pull request"
        uses: "peter-evans/create-pull-request@v6"
        with:
          title: "Codex: full generation (php, gpt-5-codex)"
          body: "Full-mode generation from specs. If the model produced no diff, a minimal PHP scaffold was created to guarantee code output."
          branch: "codex/autogen-${{ github.run_id }}"
          base: "main"
          delete-branch: true
          labels: "codex, automation"
          token: "${{ secrets.GITHUB_TOKEN }}"
