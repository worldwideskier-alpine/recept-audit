name: "Codex"

on:
  workflow_dispatch: {}
  push:
    branches: ["main"]
    paths:
      - "spec/**"

permissions:
  contents: write
  pull-requests: write

jobs:
  generate:
    name: "Generate from specs"
    runs-on: ubuntu-latest

    env:
      SPEC_ROOT: "spec"
      SPEC_DIRS: "env features foundation fountation tests"
      PROMPT_FILE: "ai/prompt.md"
      PATCH_FILE:  "ai/patch.diff"
      MODEL_DEFAULT: "gpt-4o-mini"
      OPENAI_MODEL:  "gpt-5-codex"
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      OPENAI_BASE_URL: ""

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preflight
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${OPENAI_API_KEY:-}" ] || { echo "::error::OPENAI_API_KEY is not set"; exit 1; }
          rm -rf ai
          mkdir -p ai generated

      - name: Compose prompt from specs (detect language, allowed paths)
        id: compose
        shell: bash
        run: |
          set -euo pipefail
          : > "$PROMPT_FILE"
          : > ai/allowed_paths.txt

          # ── 言語検出（キー優先 → 自由記述ヒューリスティック） ─────────────
          LANG_HINT=""
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E '^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*' "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E 's/.*[:=]\s*//; s/[",]//g; s/\s+$//;' | tr 'A-Z' 'a-z')"
              break
            fi
          done
          if [ -z "$LANG_HINT" ]; then
            t="$(grep -R -h -i -E '\b(php|typescript|javascript|node\.js|python|golang|go|ruby|java|kotlin|c#|\.net|csharp)\b' \
                 "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" 2>/dev/null | head -n1 || true)"
            case "$t" in
              *php* ) LANG_HINT="php" ;;
              *typescript*|*javascript*|*node.js*|*node\ * ) LANG_HINT="typescript" ;;
              *python* ) LANG_HINT="python" ;;
              *golang*|*" go "*|go[^a-zA-Z]* ) LANG_HINT="go" ;;
              *ruby* ) LANG_HINT="ruby" ;;
              *java* ) LANG_HINT="java" ;;
              *kotlin* ) LANG_HINT="kotlin" ;;
              *c#*|*.net*|*csharp* ) LANG_HINT="csharp" ;;
            esac
          fi
          # 正規化（代表的ラベルを丸める）
          case "${LANG_HINT:-}" in
            php*|composer*|psr*) LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*) LANG_HINT="python" ;;
            go|golang*) LANG_HINT="go" ;;
            rb|ruby*) LANG_HINT="ruby" ;;
            java*) LANG_HINT="java" ;;
            kotlin*) LANG_HINT="kotlin" ;;
            c#|dotnet*|.net*|cs|csharp) LANG_HINT="csharp" ;;
            "" ) LANG_HINT="auto" ;;
          esac
          echo "lang=${LANG_HINT}" >> "$GITHUB_OUTPUT"
          [ "$LANG_HINT" = "auto" ] && echo "::warning::Language not found in env specs; using 'auto'."

          # ── ALLOWED_PATHS 抽出（仕様に書かれた出力先/ファイルを優先） ──────
          grep -R -n -E '(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+\.[A-Za-z0-9]+)' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\'']//g' \
            | grep -E '[/A-Za-z0-9_.-]+\.[A-Za-z0-9]+' >> ai/allowed_paths.txt || true

          # 文面中の明示的な拡張子も取得（保守的に）
          grep -R -h -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|kt|cs|sql|html|css|yml|yaml|json|ini|xml)' "$SPEC_ROOT" \
            | grep -o -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|kt|cs|sql|html|css|yml|yaml|json|ini|xml)' >> ai/allowed_paths.txt || true

          # ディレクトリ指定（dir: / directory: / フォルダ）
          grep -R -h -E '(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\'']//g' | awk '{gsub(/\/?$/,"/");print}' >> ai/allowed_paths.txt || true

          sed -E 's#^\./##; s#//+#/#g' -i ai/allowed_paths.txt || true
          LC_ALL=C sort -u ai/allowed_paths.txt -o ai/allowed_paths.txt

          # ── 言語別デフォルト許可（仕様に明記が無い場合の安全網） ────────
          if [ ! -s ai/allowed_paths.txt ]; then
            case "$LANG_HINT" in
              php)
                cat >> ai/allowed_paths.txt <<'EOF'
composer.json
public/
public/.htaccess
public/index.php
src/
src/**/*.php
bin/
tests/
EOF
                ;;
              typescript)
                cat >> ai/allowed_paths.txt <<'EOF'
package.json
tsconfig.json
src/
src/**/*.ts
bin/
tests/
EOF
                ;;
              python)
                cat >> ai/allowed_paths.txt <<'EOF'
pyproject.toml
requirements.txt
src/
src/**/*.py
app.py
tests/
EOF
                ;;
              go)
                cat >> ai/allowed_paths.txt <<'EOF'
go.mod
cmd/
cmd/**/main.go
internal/
pkg/
EOF
                ;;
              ruby)
                cat >> ai/allowed_paths.txt <<'EOF'
Gemfile
bin/
lib/
lib/**/*.rb
EOF
                ;;
              java|kotlin)
                cat >> ai/allowed_paths.txt <<'EOF'
pom.xml
build.gradle
settings.gradle
src/
src/main/**
src/test/**
EOF
                ;;
              csharp)
                cat >> ai/allowed_paths.txt <<'EOF'
*.sln
*.csproj
Program.cs
src/
src/**/*.cs
EOF
                ;;
              *)
                echo "generated/" >> ai/allowed_paths.txt
                ;;
            esac
          fi

          # ── 言語別：最低生成物の正規表現 & スキャフォールド指示 ────────────
          REQUIRED_GREP=""
          SCAFFOLD_FILE="ai/scaffold.md"
          case "$LANG_HINT" in
            php)
              REQUIRED_GREP='(\+\+\+ b/composer\.json)|(\+\+\+ b/public/\.htaccess)|(\+\+\+ b/public/index\.php)|(\+\+\+ b/src/.*\.php)'
              cat > "$SCAFFOLD_FILE" <<'EOF'
Output a UNIFIED DIFF that creates a minimal PHP 8.3 project (framework-free):
- composer.json (php>=8.3, ext-curl; PSR-4 autoload App\\ => src/)
- public/.htaccess (mod_rewrite front controller)
- public/index.php (front controller)
- src/ (at least one class)
Only the diff. No prose.
EOF
              ;;
            typescript)
              REQUIRED_GREP='(\+\+\+ b/package\.json)|(\+\+\+ b/tsconfig\.json)|(\+\+\+ b/src/.*\.ts)'
              cat > "$SCAFFOLD_FILE" <<'EOF'
Output a UNIFIED DIFF for a minimal TypeScript Node project:
- package.json (type: module, scripts: build/start, deps)
- tsconfig.json (ES2020)
- src/index.ts (entry)
Only the diff. No prose.
EOF
              ;;
            python)
              REQUIRED_GREP='(\+\+\+ b/pyproject\.toml)|(\+\+\+ b/requirements\.txt)|(\+\+\+ b/src/.*\.py)|(\+\+\+ b/app\.py)'
              cat > "$SCAFFOLD_FILE" <<'EOF'
Output a UNIFIED DIFF for a minimal Python project:
- pyproject.toml or requirements.txt
- src/ or app.py with a runnable entry
Only the diff. No prose.
EOF
              ;;
            go)
              REQUIRED_GREP='(\+\+\+ b/go\.mod)|(\+\+\+ b/cmd/.*/main\.go)'
              cat > "$SCAFFOLD_FILE" <<'EOF'
Output a UNIFIED DIFF for a minimal Go project:
- go.mod
- cmd/app/main.go
Only the diff. No prose.
EOF
              ;;
            ruby)
              REQUIRED_GREP='(\+\+\+ b/Gemfile)|(\+\+\+ b/lib/.*\.rb)'
              cat > "$SCAFFOLD_FILE" <<'EOF'
Output a UNIFIED DIFF for a minimal Ruby project:
- Gemfile
- lib/**.rb with an entry in bin/
Only the diff. No prose.
EOF
              ;;
            java|kotlin)
              REQUIRED_GREP='(\+\+\+ b/pom\.xml)|(\+\+\+ b/build\.gradle)|(\+\+\+ b/src/main/.*\.(java|kt))'
              cat > "$SCAFFOLD_FILE" <<'EOF'
Output a UNIFIED DIFF for a minimal JVM project:
- Maven or Gradle build file
- src/main/** with at least one class
Only the diff. No prose.
EOF
              ;;
            csharp)
              REQUIRED_GREP='(\+\+\+ b/.*\.csproj)|(\+\+\+ b/Program\.cs)|(\+\+\+ b/src/.*\.cs)'
              cat > "$SCAFFOLD_FILE" <<'EOF'
Output a UNIFIED DIFF for a minimal .NET project:
- *.csproj
- Program.cs (top-level statements ok)
Only the diff. No prose.
EOF
              ;;
            *)
              REQUIRED_GREP='(\+\+\+ b/src/)'
              echo "Output a UNIFIED DIFF that adds a minimal project with src/ and an entry file." > "$SCAFFOLD_FILE"
              ;;
          esac
          echo "required_grep<<EOF" >> "$GITHUB_OUTPUT"
          echo "$REQUIRED_GREP" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "scaffold_file=$SCAFFOLD_FILE" >> "$GITHUB_OUTPUT"

          # ── プロンプト本文：言語・環境・許可パス・仕様本文を束ねる ───────────
          {
            printf "# Codex generation prompt\n\n"
            printf "## LANGUAGE (MUST)\n\nlanguage: %s\n" "$LANG_HINT"
            printf "\n## ALLOWED_PATHS (only modify/create under these)\n\n"
            awk '{print "- " $0}' ai/allowed_paths.txt
            printf "\n## SPEC (excerpt; first 4000 lines per file)\n"
          } >> "$PROMPT_FILE"

          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e 's/\r$//' "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

          {
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Return ONE unified diff (UTF-8), repository-rooted; no prose, no code fences.\n"
            printf -- "- Respect LANGUAGE and ALLOWED_PATHS. Do NOT invent files the spec didn't name.\n"
          } >> "$PROMPT_FILE"

      - name: Call OpenAI (primary)
        id: call1
        shell: bash
        run: |
          set -euo pipefail
          MODEL="${OPENAI_MODEL:-$MODEL_DEFAULT}"
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
          SYSTEM="You output only a unified diff. Follow LANGUAGE and ALLOWED_PATHS strictly."
          if printf "%s" "$MODEL" | grep -qiE '^gpt-5-codex( |$|-|:)'; then
            jq -n --arg model "$MODEL" --arg sys "$SYSTEM" --rawfile prompt "$PROMPT_FILE" \
              '{model:$model,max_output_tokens:4096,
                input:[{role:"system",content:[{type:"input_text",text:$sys}]},
                       {role:"user",content:[{type:"input_text",text:$prompt}]}]}' > ai/request.json
            EP="${BASE%/}/v1/responses"
          else
            jq -n --arg model "$MODEL" --arg sys "$SYSTEM" --rawfile prompt "$PROMPT_FILE" \
              '{model:$model,temperature:0,max_tokens:4096,
                messages:[{role:"system",content:$sys},{role:"user",content:$prompt}]}' > ai/request.json
            EP="${BASE%/}/v1/chat/completions"
          fi
          curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
               -d @ai/request.json "$EP" > ai/response.json
          jq -r '
            [.output_text,
             (try(.output|if type=="array" then map(.content|if type=="array" then map(.text // .string // .content // "")|join("") else (. // "") end)|join("") else "" end) catch ""),
             .choices[0].message.content,.choices[0].text]
            | map(select(type=="string" and .!="")) | .[0]//""' ai/response.json > ai/out.txt
          sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i ai/out.txt || true
          awk 'f||/^(diff --git|--- a\/)/{f=1; print}' ai/out.txt > "$PATCH_FILE" || true

      - name: Validate patch & scaffold if needed
        id: validate
        shell: bash
        run: |
          set -euo pipefail
          REQ='${{ steps.compose.outputs.required_grep }}'
          if ! grep -Eq '^(diff --git|--- a/)' "$PATCH_FILE"; then
            echo "::warning::primary result is not a diff; forcing scaffold"
            > "$PATCH_FILE"
          fi
          need=0
          if ! [ -s "$PATCH_FILE" ]; then need=1; fi
          if [ "$need" -eq 0 ] && ! grep -Eq "$REQ" "$PATCH_FILE"; then
            echo "::warning::diff lacks minimum deliverables; forcing scaffold"
            need=1
          fi
          if [ "$need" -eq 1 ]; then
            MODEL="${OPENAI_MODEL:-$MODEL_DEFAULT}"
            BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
            SCAF='${{ steps.compose.outputs.scaffold_file }}'
            if printf "%s" "$MODEL" | grep -qiE '^gpt-5-codex( |$|-|:)'; then
              jq -n --arg model "$MODEL" --rawfile prompt "$SCAF" \
                '{model:$model,max_output_tokens:4096,input:[{role:"user",content:[{type:"input_text",text:$prompt}]}]}' \
                > ai/request.repair.json
              EP="${BASE%/}/v1/responses"
            else
              jq -n --arg model "$MODEL" --rawfile prompt "$SCAF" \
                '{model:$model,temperature:0,max_tokens:4096,messages:[{role:"user",content:$prompt}]}' \
                > ai/request.repair.json
              EP="${BASE%/}/v1/chat/completions"
            fi
            curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                 -d @ai/request.repair.json "$EP" > ai/response.repair.json
            jq -r '
              [.output_text,
               (try(.output|if type=="array" then map(.content|if type=="array" then map(.text // .string // .content // "")|join("") else (. // "") end)|join("") else "" end) catch ""),
               .choices[0].message.content,.choices[0].text]
              | map(select(type=="string" and .!="")) | .[0]//""' ai/response.repair.json > ai/out.repair.txt
            sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i ai/out.repair.txt || true
            awk 'f||/^(diff --git|--- a\/)/{f=1; print}' ai/out.repair.txt > "$PATCH_FILE" || true
          fi
          # 最終妥当性
          if ! grep -Eq '^(diff --git|--- a/)' "$PATCH_FILE"; then
            echo "::error::model did not return a unified diff"
            exit 4
          fi
          if ! grep -Eq "$REQ" "$PATCH_FILE"; then
            echo "::error::diff does not include language-specific minimum deliverables"
            exit 4
          fi

      - name: Apply patch
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          # 通常適用。失敗時は 3-way で救済（full 生成なので止めない）
          if git apply --check "$PATCH_FILE"; then
            git apply --index --whitespace=fix "$PATCH_FILE"
          else
            echo "::warning::git apply check failed; attempting 3-way merge apply"
            git apply --3way --index --whitespace=fix "$PATCH_FILE" || true
          fi
          # PR に不要なゴミの除外
          git restore --staged --worktree -- STATE.json 2>/dev/null || true
          rm -f STATE.json || true

      - name: Upload AI artifacts (before PR)
        uses: actions/upload-artifact@v4
        with:
          name: ai-artifacts
          path: ai/**
          if-no-files-found: warn

      - name: Remove ai/ to keep PR clean
        shell: bash
        run: rm -rf ai

      - name: List staged files for PR
        id: staged
        shell: bash
        run: |
          set -euo pipefail
          git diff --name-only --cached | sed '/^ai\//d;/^STATE\.json$/d' | tee pr-files.txt
          if [ ! -s pr-files.txt ]; then
            echo "::error::No staged files for PR"
            exit 6
          fi
          printf "files<<EOF\n%s\nEOF\n" "$(cat pr-files.txt)" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request (staged files only)
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Codex: generate per spec (lang=${{ steps.compose.outputs.lang }})"
          body: |
            Generated strictly from environment specs and ALLOWED_PATHS.
            Only staged files are included in this PR.
          branch: "codex/autogen-${{ github.run_id }}"
          base: "main"
          delete-branch: true
          labels: "codex, automation"
          add-paths: ${{ steps.staged.outputs.files }}
