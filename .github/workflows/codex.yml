name: "codex"

on:
  workflow_dispatch: {}

permissions:
  contents: "write"
  pull-requests: "write"

env:
  SPEC_ROOT: "spec"
  SPEC_DIRS: "env foundation features tests"
  PROMPT_FILE: "ai/prompt.md"
  FILES_JSON: "ai/files.json"
  OPENAI_MODEL: "gpt-5-codex"
  BRANCH_PREFIX: "codex/autogen"
  MAX_TOKENS: "12288"
  CURL_TIMEOUT: "300"
  CURL_RETRIES: "5"
  CURL_RETRY_DELAY: "5"
  # 公開で問題ない固定エンドポイント（ご要望どおり secrets 不要）
  ENDPOINT: "https://api.openai.com/v1/chat/completions"

jobs:
  generate:
    name: "generate"
    runs-on: "ubuntu-24.04"
    steps:
      - name: "Checkout"
        uses: "actions/checkout@v4"
        with:
          ref: "main"

      - name: "Compose prompt and allowed paths"
        shell: "bash"
        env:
          SPEC_ROOT: "${{ env.SPEC_ROOT }}"
          SPEC_DIRS: "${{ env.SPEC_DIRS }}"
          PROMPT_FILE: "${{ env.PROMPT_FILE }}"
        run: |
          set -euo pipefail
          mkdir -p "ai"
          : > "ai/allowed_paths.txt"
          : > "$PROMPT_FILE"

          LANG_HINT=""
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/features" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E "^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*" "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E "s/.*[:=]\s*//; s/[\",]//g; s/\s+$//;" | tr "A-Z" "a-z")"
              break
            fi
          done
          case "${LANG_HINT:-}" in
            php*|composer*|psr*) LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*)          LANG_HINT="python" ;;
            go|golang*)          LANG_HINT="go" ;;
            ruby*)               LANG_HINT="ruby" ;;
            java*)               LANG_HINT="java" ;;
            c#|dotnet*|.net*|cs) LANG_HINT="csharp" ;;
            "" )                 LANG_HINT="auto" ;;
          esac
          if [ "$LANG_HINT" = "auto" ]; then
            if   find . -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) -print -quit | grep -q .; then LANG_HINT="typescript"
            elif find . -type f -name "*.py" -print -quit | grep -q .; then LANG_HINT="python"
            elif find . -type f -name "*.php" -print -quit | grep -q . || [ -f composer.json ]; then LANG_HINT="php"
            elif [ -f go.mod ]; then LANG_HINT="go"
            else LANG_HINT="typescript"
            fi
          fi
          echo "lang_hint=$LANG_HINT" >> "$GITHUB_OUTPUT"

          # allowlist 候補収集
          grep -R -n -E '(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+(\.[A-Za-z0-9]+)?)' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\'']//g' >> "ai/allowed_paths.txt" || true
          grep -R -h -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml|env|conf|cfg|sh|htaccess)' "$SPEC_ROOT" \
            | grep -o -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml|env|conf|cfg|sh|htaccess)' >> "ai/allowed_paths.txt" || true
          grep -R -h -E '(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\'']//g' | awk '{gsub(/\/?$/,"/");print}' >> "ai/allowed_paths.txt" || true

          # 最低限のデフォルト
          if ! grep -Eq '\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql)$' ai/allowed_paths.txt; then
            case "$LANG_HINT" in
              typescript) printf "%s\n" "src/" "app/" "lib/" "package.json" "tsconfig.json" >> ai/allowed_paths.txt ;;
              python)     printf "%s\n" "src/" "app/" "pyproject.toml" "requirements.txt" >> ai/allowed_paths.txt ;;
              php)        printf "%s\n" "src/" "app/" "public/" "composer.json" >> ai/allowed_paths.txt ;;
              go)         printf "%s\n" "cmd/" "internal/" "pkg/" "go.mod" >> ai/allowed_paths.txt ;;
            esac
          fi

          sed -E 's#^\./##; s#//+#/#g' -i "ai/allowed_paths.txt" || true
          LC_ALL=C sort -u -o "ai/allowed_paths.txt" "ai/allowed_paths.txt"

          {
            printf "# Codex generation prompt\n\n"
            printf "## LANGUAGE (MUST)\n\nlanguage: %s\n" "$LANG_HINT"
            printf "\n## ALLOWED_PATHS (only modify/create under these; NEVER touch ai/)\n\n"
            while IFS= read -r line; do printf -- "- %s\n" "$line"; done < "ai/allowed_paths.txt"
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Use the tool function \`emit_files\` to return files to create/modify.\n"
            printf -- "- Implement the SPEC as runnable APPLICATION CODE and TESTS under ALLOWED_PATHS.\n"
            printf -- "- Do NOT create compliance/policy/README/meta documents.\n"
            printf -- "- Include real code (no placeholders).\n"
          } >> "$PROMPT_FILE"

          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e 's/\r$//' "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

      - name: "Create working branch"
        shell: "bash"
        env:
          BRANCH_PREFIX: "${{ env.BRANCH_PREFIX }}"
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          BRANCH_NAME="${BRANCH_PREFIX}-${GITHUB_RUN_ID}"
          git checkout -b "${BRANCH_NAME}"
          echo "BRANCH_NAME=${BRANCH_NAME}" >> "$GITHUB_ENV"

      - name: "Call model (tool calling) and materialize files"
        shell: "bash"
        env:
          ENDPOINT: "${{ env.ENDPOINT }}"
          OPENAI_MODEL: "${{ env.OPENAI_MODEL }}"
          MAX_TOKENS: "${{ env.MAX_TOKENS }}"
          PROMPT_FILE: "${{ env.PROMPT_FILE }}"
          FILES_JSON: "${{ env.FILES_JSON }}"
          CURL_TIMEOUT: "${{ env.CURL_TIMEOUT }}"
          CURL_RETRIES: "${{ env.CURL_RETRIES }}"
          CURL_RETRY_DELAY: "${{ env.CURL_RETRY_DELAY }}"
          # API キーのみ secrets から取得（Bearer で送信）
          OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
        run: |
          set -euo pipefail
          command -v jq >/dev/null || (sudo apt-get update -y && sudo apt-get install -y jq coreutils)

          tools_json=$(cat <<'JSON'
          [
            {
              "type": "function",
              "function": {
                "name": "emit_files",
                "description": "Create or modify project files. Return all files to write.",
                "parameters": {
                  "type": "object",
                  "additionalProperties": false,
                  "required": ["files"],
                  "properties": {
                    "files": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "additionalProperties": false,
                        "required": ["path","content"],
                        "properties": {
                          "path":    { "type": "string", "minLength": 1 },
                          "content": { "type": "string" }
                        }
                      }
                    }
                  }
                }
              }
            }
          ]
          JSON
          )

          read -r -d '' SYS_MSG <<'EOS'
          You MUST call the function tool "emit_files" only. Do not write prose or code fences.
          Implement runnable application code and tests strictly under ALLOWED_PATHS.
          Skip compliance/policy/README/meta docs. Use real code with no placeholders.
          EOS

          jq -n \
            --arg model "$OPENAI_MODEL" \
            --rawfile prompt "$PROMPT_FILE" \
            --argjson tools "$tools_json" \
            --arg sys "$SYS_MSG" \
            --argjson max_tokens "${MAX_TOKENS:-0}" \
            '{
              model: $model,
              messages: [
                {role:"system", content:$sys},
                {role:"user",   content:$prompt}
              ],
              tools: $tools,
              tool_choice: {type:"function", function:{name:"emit_files"}}
            } + ( ($max_tokens|tonumber) > 0
                ? {max_tokens: ($max_tokens|tonumber)}
                : {} )' > "ai/request.tools.json"

          call_api_with_retry() {
            local req="$1"; local out="$2"; local attempt=1
            while [ "$attempt" -le 3 ]; do
              local tmp; tmp="$(mktemp)"
              curl -sS --connect-timeout 30 --max-time "$CURL_TIMEOUT" \
                   --retry "$CURL_RETRIES" --retry-all-errors --retry-delay "$CURL_RETRY_DELAY" \
                   -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                   -w "\n%{http_code}\n" -d @"$req" "$ENDPOINT" | tee "$tmp" >/dev/null
              local status; status="$(tail -n1 "$tmp")"
              head -n -1 "$tmp" > "$out"; rm -f "$tmp"
              echo "::notice::OpenAI HTTP status: ${status}"
              [ "$status" -lt 300 ] && return 0
              case "$status" in
                408|429|500|502|503|504) attempt=$((attempt+1)); continue ;;
                *)   return 2 ;;
              esac
            done
            return 2
          }

          call_api_with_retry "ai/request.tools.json" "ai/response.tools.json" || true
          cp -f "ai/response.tools.json" "ai/response.raw.json" || true

          jq -r '
            (.choices[0].message.tool_calls // [])
            | map(select(.type=="function" and .function.name=="emit_files"))
            | .[0].function.arguments // empty
          ' "ai/response.tools.json" > "ai/out.files.txt" || true

          if ! jq -e . "ai/out.files.txt" >/dev/null 2>&1; then
            echo "::group::raw tool arguments (first 2KB)"
            head -c 2048 "ai/out.files.txt" | sed "s/^/RAW: /"
            echo "::endgroup::"
            echo "::error::Tool arguments were not valid JSON"
            exit 7
          fi

          jq -c '
            def to_text(x):
              if x==null then "" elif (x|type)=="string" then x
              elif (x|type)=="array" then (x|map(tostring)|join("\n"))
              elif (x|type)=="object" and has("code") then to_text(.code)
              elif (x|type)=="object" and has("text") then to_text(.text)
              else tostring end;
            .files
            | (if type=="array" then . else [] end)
            | map({
                path:    ((.path // .file // .name // .filename // "") | tostring),
                content: to_text(.content // .code // .text // "")
              })
          ' "ai/out.files.txt" > "$FILES_JSON"

          allow_all=0
          if [ -s "ai/allowed_paths.txt" ]; then mapfile -t ALLOWED < "ai/allowed_paths.txt"; else allow_all=1; fi

          jq -r '.[] | @base64' "$FILES_JSON" | while read -r row; do
            _jq(){ echo "$row" | base64 -d | jq -r "$1"; }
            p="$(_jq '.path')"; c="$(_jq '.content')"
            case "$p" in ai/*) echo "::warning::skip ai/: $p"; continue ;; esac
            if printf "%s" "$p" | grep -qiE '(COMPLIANCE|SECURITY|CODE_OF_CONDUCT|CONTRIBUTING|README)\.(md|txt|json)$'; then
              echo "::warning::skip non-code doc: $p"; continue
            fi
            ok="$allow_all"
            if [ "$allow_all" -ne 1 ]; then
              for pat in "${ALLOWED[@]}"; do
                if [ "${p#"$pat"}" != "$p" ] || [ "$p" = "$pat" ]; then ok=1; break; fi
              done
            fi
            [ "$ok" -ne 1 ] && { echo "::warning::skip (not allowed): $p"; continue; }
            mkdir -p "$(dirname "$p")"
            printf "%s" "$c" > "$p"
            git add "$p"
          done

          if ! git diff --cached --name-only | grep -q "."; then
            echo "::error::No changes staged after all paths"; exit 6
          fi

          if ! git diff --cached --name-only | grep -E '\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|sh|conf|cfg)$|(^|/)\.htaccess$|(^|/)Dockerfile$|(^|/)Makefile$' >/dev/null; then
            echo "::error::No code files staged (only non-code docs). Aborting."; exit 6
          fi

          git commit -m "codex(init): seed from specs via ${OPENAI_MODEL}"

      - name: "Push branch"
        shell: "bash"
        env:
          BRANCH_NAME: "${{ env.BRANCH_NAME }}"
        run: |
          set -euo pipefail
          git push -u "origin" "${BRANCH_NAME}"

      - name: "Open pull request"
        uses: "actions/github-script@v7"
        with:
          script: |
            const branch = process.env.BRANCH_NAME;
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: "codex(init): seed from specs",
              head: branch,
              base: "main",
              body: "Auto-generated by codex.yml"
            });
            core.setOutput("pr", pr.html_url);

      - name: "Upload artifacts"
        if: "always()"
        uses: "actions/upload-artifact@v4"
        with:
          name: "ai-debug"
          path: |
            ai/request.tools.json
            ai/response.tools.json
            ai/response.raw.json
            ai/out.files.txt
            ai/files.json
            ai/prompt.md
            ai/allowed_paths.txt
