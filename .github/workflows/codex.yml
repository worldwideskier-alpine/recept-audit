name: "Codex"

on:
  workflow_dispatch:

permissions:
  contents: write

env:
  SPEC_ROOT: "spec"
  SPEC_DIRS: "env foundation features tests"
  PROMPT_FILE: "ai/prompt.md"
  PATCH_FILE: "ai/patch.diff"
  FILES_JSON: "ai/files.json"
  PLAN_JSON: "ai/plan.json"
  OPENAI_MODEL: "gpt-5-codex"
  OPENAI_BASE_URL: ""
  BRANCH_PREFIX: "codex/autogen"
  MAX_OUT_TOKENS: "12288"
  TEMPERATURE: "0"
  CURL_TIMEOUT: "300"
  CURL_RETRIES: "5"
  CURL_RETRY_DELAY: "5"
  MAX_PASSES: "3"
  BATCH_SIZE: "12"
  PLAN_MAX_FILES: "120"

jobs:
  generate:
    name: "Generate from specs (full → new branch)"
    runs-on: "ubuntu-latest"
    timeout-minutes: 45
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

    steps:
      - name: "Checkout"
        uses: "actions/checkout@v4"
        with:
          ref: "main"
          fetch-depth: 1

      - name: "Sanity / tools"
        shell: "bash"
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is not set"; exit 1
          fi
          mkdir -p ai
          command -v jq >/dev/null || (sudo apt-get update -y && sudo apt-get install -y jq coreutils)

      - id: "probe_api"
        name: "Probe OpenAI API (responses/chat & temperature)"
        shell: "bash"
        run: |
          set -euo pipefail
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"; BASE="${BASE%/}"
          MODEL="${OPENAI_MODEL}"

          r_tmp="$(mktemp)"
          r_req='{"model":"'"$MODEL"'","input":[{"role":"user","content":[{"type":"input_text","text":"ping"}]}],"max_output_tokens":32}'
          curl -sS -w "\n%{http_code}\n" \
               -H "Authorization: Bearer ${OPENAI_API_KEY}" \
               -H "Content-Type: application/json" \
               -d "$r_req" "$BASE/v1/responses" | tee "$r_tmp" >/dev/null
          r_code="$(tail -n1 "$r_tmp")"
          head -n -1 "$r_tmp" > ai/probe.responses.json || true
          rm -f "$r_tmp"

          c_tmp="$(mktemp)"
          c_req='{"model":"'"$MODEL"'","max_tokens":16,"messages":[{"role":"system","content":"Reply with OK."},{"role":"user","content":"ping"}]}'
          curl -sS -w "\n%{http_code}\n" \
               -H "Authorization: Bearer ${OPENAI_API_KEY}" \
               -H "Content-Type: application/json" \
               -d "$c_req" "$BASE/v1/chat/completions" | tee "$c_tmp" >/dev/null
          c_code="$(tail -n1 "$c_tmp")"
          head -n -1 "$c_tmp" > ai/probe.chat.json || true
          rm -f "$c_tmp"

          api="responses"
          if [ "$r_code" -lt 300 ] && [ "$c_code" -ge 300 ]; then api="responses"; fi
          if [ "$c_code" -lt 300 ] && [ "$r_code" -ge 300 ]; then api="chat"; fi
          if [ "$c_code" -lt 300 ] && [ "$r_code" -lt 300 ]; then api="responses"; fi

          t_tmp="$(mktemp)"
          if [ "$api" = "responses" ]; then
            t_req='{"model":"'"$MODEL"'","input":[{"role":"user","content":[{"type":"input_text","text":"ping"}]}],"max_output_tokens":32,"temperature":0}'
            t_url="$BASE/v1/responses"
          else
            t_req='{"model":"'"$MODEL"'","max_tokens":16,"temperature":0,"messages":[{"role":"user","content":"ping"}]}'
            t_url="$BASE/v1/chat/completions"
          fi
          curl -sS -w "\n%{http_code}\n" \
               -H "Authorization: Bearer ${OPENAI_API_KEY}" \
               -H "Content-Type: application/json" \
               -d "$t_req" "$t_url" | tee "$t_tmp" >/dev/null
          t_code="$(tail -n1 "$t_tmp")"
          head -n -1 "$t_tmp" > ai/probe.temperature.json || true
          rm -f "$t_tmp"

          allow_temp=1
          if [ "$t_code" -ge 300 ] && command -v jq >/dev/null 2>&1; then
            msg="$(jq -r '.error?.message // empty' ai/probe.temperature.json)"
            case "$msg" in *"Unsupported parameter"*temperature* ) allow_temp=0 ;; esac
            [ -n "$msg" ] && echo "::notice::temperature probe: $msg"
          fi

          echo "base=$BASE"             >> "$GITHUB_OUTPUT"
          echo "api=$api"               >> "$GITHUB_OUTPUT"
          echo "allow_temp=$allow_temp" >> "$GITHUB_OUTPUT"

      - id: "probe_json_schema"
        name: "Probe response_format: json_schema support"
        shell: "bash"
        run: |
          set -euo pipefail
          BASE="${{ steps.probe_api.outputs.base }}"
          MODEL="${OPENAI_MODEL}"
          j_tmp="$(mktemp)"
          j_req='{
            "model":"'"$MODEL"'",
            "input":[{"role":"user","content":[{"type":"input_text","text":"{}"}]}],
            "max_output_tokens": 16,
            "response_format":{
              "type":"json_schema",
              "json_schema":{
                "name":"files_payload",
                "schema":{
                  "type":"object",
                  "additionalProperties": false,
                  "required":["files"],
                  "properties":{
                    "files":{
                      "type":"array",
                      "items":{
                        "type":"object",
                        "additionalProperties": false,
                        "required":["path","content"],
                        "properties":{
                          "path":{"type":"string","minLength":1},
                          "content":{"type":"string"}
                        }
                      }
                    }
                  }
                }
              }
            }
          }'
          curl -sS -w "\n%{http_code}\n" \
               -H "Authorization: Bearer ${OPENAI_API_KEY}" \
               -H "Content-Type: application/json" \
               -d "$j_req" "$BASE/v1/responses" | tee "$j_tmp" >/dev/null
          j_code="$(tail -n1 "$j_tmp")"
          head -n -1 "$j_tmp" > ai/probe.response_format.json || true
          rm -f "$j_tmp"
          allow_json_schema=0; [ "$j_code" -lt 300 ] && allow_json_schema=1
          echo "allow_json_schema=$allow_json_schema" >> "$GITHUB_OUTPUT"

      - id: "prepare_prompt"
        name: "Build prompt & allowed paths"
        shell: "bash"
        run: |
          set -euo pipefail
          : > "ai/allowed_paths.txt"
          : > "$PROMPT_FILE"

          LANG_HINT=""
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/features" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E "^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*" "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E "s/.*[:=]\s*//; s/[\",]//g; s/\s+$//;" | tr "A-Z" "a-z")"; break
            fi
          done
          case "${LANG_HINT:-}" in
            php*|composer*|psr*) LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*)          LANG_HINT="python" ;;
            go|golang*)          LANG_HINT="go" ;;
            ruby*)               LANG_HINT="ruby" ;;
            java*)               LANG_HINT="java" ;;
            c#|dotnet*|.net*|cs) LANG_HINT="csharp" ;;
            "" )                 LANG_HINT="auto" ;;
          esac
          if [ "$LANG_HINT" = "auto" ]; then
            if   find . -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) -print -quit | grep -q .; then LANG_HINT="typescript"
            elif find . -type f -name "*.py" -print -quit | grep -q .; then LANG_HINT="python"
            elif find . -type f -name "*.php" -print -quit | grep -q . || [ -f composer.json ]; then LANG_HINT="php"
            elif [ -f go.mod ]; then LANG_HINT="go"
            else LANG_HINT="typescript"
            fi
          fi
          echo "lang_hint=$LANG_HINT" >> "$GITHUB_OUTPUT"

          grep -R -n -E "(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+(\.[A-Za-z0-9]+)?)" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" >> "ai/allowed_paths.txt" || true
          grep -R -h -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml|env|conf|cfg|sh|htaccess)" "$SPEC_ROOT" \
            | grep -o -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml|env|conf|cfg|sh|htaccess)" >> "ai/allowed_paths.txt" || true
          grep -R -h -E "(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" | awk '{gsub(/\/?$/,"/");print}' >> "ai/allowed_paths.txt" || true

          if ! grep -Eq '\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql)$' ai/allowed_paths.txt; then
            case "$LANG_HINT" in
              typescript) printf "%s\n" "src/" "app/" "lib/" "package.json" "tsconfig.json" >> ai/allowed_paths.txt ;;
              python)     printf "%s\n" "src/" "app/" "pyproject.toml" "requirements.txt" >> ai/allowed_paths.txt ;;
              php)        printf "%s\n" "src/" "app/" "public/" "composer.json" >> ai/allowed_paths.txt ;;
              go)         printf "%s\n" "cmd/" "internal/" "pkg/" "go.mod" >> ai/allowed_paths.txt ;;
            esac
          fi

          sed -E "s#^\./##; s#//+#/#g" -i "ai/allowed_paths.txt" || true
          LC_ALL=C sort -u -o ai/allowed_paths.txt ai/allowed_paths.txt

          {
            printf "# Codex generation prompt\n\n"
            printf "## LANGUAGE (MUST)\n\nlanguage: %s\n" "$LANG_HINT"
            printf "\n## ALLOWED_PATHS (only modify/create under these; NEVER touch ai/)\n\n"
            while IFS= read -r line; do printf -- "- %s\n" "$line"; done < "ai/allowed_paths.txt"
            printf "\n## Example header (force unified diff)\n\ndiff --git a/app.php b/app.php\n"
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Output ONE Git unified diff (UTF-8). No prose, no code fences.\n"
            printf -- "- MUST start with: diff --git a/<path> b/<path>\n"
            printf -- "- Implement the SPEC as runnable APPLICATION CODE and TESTS under ALLOWED_PATHS.\n"
            printf -- "- Do NOT create compliance/policy/README/meta documents.\n"
            printf -- "- Include real code (no placeholders). If initial attempt fails, still SYNTHESIZE a complete diff that fulfills the specs.\n"
          } >> "$PROMPT_FILE"

          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e "s/\r$//" "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

      - name: "Write jq filters (extract & normalize)"
        shell: "bash"
        run: |
          set -euo pipefail
          {
            printf 'def texts:\n'
            printf '  (try(.output_text) // empty),\n'
            printf '  (try(.output[]?.content[]? |\n'
            printf '      if has("text") then .text\n'
            printf '      elif has("json") then (.json | tojson)\n'
            printf '      else empty end) // empty),\n'
            printf '  (try(.choices[0].message.content) // empty),\n'
            printf '  (try(.choices[0].text) // empty);\n'
            printf '[ texts ] | map(select(type=="string" and . != "")) | first // ""\n'
          } > "ai/extract.jq"

          {
            printf 'def to_text(x):\n'
            printf '  if x==null then ""\n'
            printf '  elif (x|type)=="string" then x\n'
            printf '  elif (x|type)=="array" then (x|map(tostring)|join("\\n"))\n'
            printf '  elif (x|type)=="object" and (x|has("code")) then to_text(x.code)\n'
            printf '  elif (x|type)=="object" and (x|has("text")) then to_text(x.text)\n'
            printf '  else tostring end;\n'
            printf 'def pick_files:\n'
            printf '  if (type=="object") and has("files") and (.files|type)=="array" then (.files)\n'
            printf '  elif (type=="array") then .\n'
            printf '  elif (type=="object") and (has("path") and has("content")) then [ {path:.path, content:.content} ]\n'
            printf '  elif (type=="object") then ( [ .[] ] | map(pick_files) | add? ) // []\n'
            printf '  else [] end;\n'
            printf 'pick_files\n'
            printf '| map({ path: ( ( .path // .file // .name // .filename // "" ) | tostring ),\n'
            printf '        content: to_text( ( .content // .code // .text // "" ) ) })\n'
          } > "ai/normalize.jq"

      - id: "set_api"
        name: "Set API endpoint"
        shell: "bash"
        run: |
          set -euo pipefail
          BASE="${{ steps.probe_api.outputs.base }}"
          API_KIND="${{ steps.probe_api.outputs.api }}"
          ALLOW_TEMPERATURE="${{ steps.probe_api.outputs.allow_temp }}"
          if [ "$API_KIND" = "chat" ]; then ENDPOINT="${BASE}/v1/chat/completions"; else ENDPOINT="${BASE}/v1/responses"; fi
          echo "endpoint=$ENDPOINT" >> "$GITHUB_OUTPUT"
          echo "allow_temp=$ALLOW_TEMPERATURE" >> "$GITHUB_OUTPUT"

      - name: "Create working branch"
        shell: "bash"
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          BRANCH_NAME="${BRANCH_PREFIX}-${GITHUB_RUN_ID}"
          git checkout -b "${BRANCH_NAME}"

      - name: "Generate & seed (diff → files JSON fallback with json_schema)"
        shell: "bash"
        env:
          ENDPOINT: ${{ steps.set_api.outputs.endpoint }}
          ALLOW_TEMPERATURE: ${{ steps.set_api.outputs.allow_temp }}
          ALLOW_JSON_SCHEMA: ${{ steps.probe_json_schema.outputs.allow_json_schema }}
        run: |
          set -euo pipefail
          MODEL="${OPENAI_MODEL}"

          gen_req() {
            local system_text="$1"; local user_file="$2"; local out_file="$3"
            if [ "${ENDPOINT##*/}" = "completions" ]; then
              if [ "$ALLOW_TEMPERATURE" -eq 1 ]; then
                jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --arg temp "$TEMPERATURE" --arg sys "$system_text" --rawfile prompt "$user_file" \
                  '{ "model":$model, "max_tokens":($max|tonumber), "temperature":($temp|tonumber),
                     "messages":[{"role":"system","content":$sys},{"role":"user","content":$prompt}] }' > "$out_file"
              else
                jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --arg sys "$system_text" --rawfile prompt "$user_file" \
                  '{ "model":$model, "max_tokens":($max|tonumber),
                     "messages":[{"role":"system","content":$sys},{"role":"user","content":$prompt}] }' > "$out_file"
              fi
            else
              if [ "$ALLOW_TEMPERATURE" -eq 1 ]; then
                jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --arg temp "$TEMPERATURE" --arg sys "$system_text" --rawfile prompt "$user_file" \
                  '{ "model":$model, "max_output_tokens":($max|tonumber), "temperature":($temp|tonumber),
                     "input":[ {"role":"system","content":[{"type":"input_text","text":$sys}]},
                               {"role":"user","content":[{"type":"input_text","text":$prompt}]} ] }' > "$out_file"
              else
                jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --arg sys "$system_text" --rawfile prompt "$user_file" \
                  '{ "model":$model, "max_output_tokens":($max|tonumber),
                     "input":[ {"role":"system","content":[{"type":"input_text","text":$sys}]},
                               {"role":"user","content":[{"type":"input_text","text":$prompt}]} ] }' > "$out_file"
              fi
            fi
          }

          call_api_with_retry() {
            local req="$1"; local out="$2"
            local attempt=1
            while [ $attempt -le 3 ]; do
              local tmp="$(mktemp)"
              curl -sS --connect-timeout 30 --max-time "$CURL_TIMEOUT" \
                   --retry "$CURL_RETRIES" --retry-all-errors --retry-delay "$CURL_RETRY_DELAY" \
                   -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                   -w "\n%{http_code}\n" -d @"$req" "$ENDPOINT" | tee "$tmp" >/dev/null
              local status; status="$(tail -n1 "$tmp")"
              head -n -1 "$tmp" > "$out"; rm -f "$tmp"
              [ "$status" -lt 300 ] && return 0
              local msg=""; command -v jq >/dev/null 2>&1 && msg="$(jq -r '.error?.message // empty' "$out")"
              [ -n "$msg" ] && echo "::notice::API error $status: $msg"
              case "$status" in
                408|429|500|502|503|504) echo "::warning::transient ${status}; shrinking tokens and retrying"; MAX_OUT_TOKENS=$(( MAX_OUT_TOKENS / 2 )); [ "$MAX_OUT_TOKENS" -lt 4096 ] && MAX_OUT_TOKENS=4096; attempt=$((attempt+1)); continue ;;
                400) echo "::error::fatal 400 for this model/endpoint"; return 2 ;;
                *) echo "::error::fatal ${status}"; return 2 ;;
              esac
            done
            return 2
          }

          system1=$'Output ONLY a Git unified diff.\nMUST start with: diff --git a/<path> b/<path>\nNo prose or fences.'
          gen_req "$system1" "$PROMPT_FILE" "ai/request.json"
          for _ in 1 2 3; do
            if call_api_with_retry "ai/request.json" "ai/response.json"; then break
            else gen_req "$system1" "$PROMPT_FILE" "ai/request.json"; fi
          done
          jq -r -f "ai/extract.jq" "ai/response.json" > "ai/out.txt"
          sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i "ai/out.txt" || true
          awk 'f||/^(diff --git|--- a\/|\*\*\* |Index: )/{f=1; print}' "ai/out.txt" > "$PATCH_FILE" || true

          is_unified=0
          if grep -Eq "^(diff --git|--- (a\/|\/dev\/null)|Index: |\*\*\* )" "$PATCH_FILE" \
             && grep -Eq "(\+\+\+ b\/|^diff --git|^--- b\/)" "$PATCH_FILE"; then
            is_unified=1
          fi
          if [ "$is_unified" -eq 1 ]; then
            if git apply --check "$PATCH_FILE"; then git apply --index --whitespace=fix "$PATCH_FILE"
            else echo "::warning::git apply check failed; attempting 3-way merge"; git apply --3way --index --whitespace=fix "$PATCH_FILE" || true; fi
          fi

          if ! git diff --cached --name-only | grep -q "."; then
            echo "::warning::No staged changes after diff path; switching to files-JSON fallback"

            if [ "${ALLOW_JSON_SCHEMA}" = "1" ] && [ "${ENDPOINT##*/}" != "completions" ]; then
              jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --rawfile prompt "$PROMPT_FILE" \
                '{
                  model:$model,
                  max_output_tokens:($max|tonumber),
                  input:[
                    {"role":"system","content":[{"type":"input_text","text":"Return ONLY JSON matching the schema; no prose."}]},
                    {"role":"user","content":[{"type":"input_text","text":$prompt}]}
                  ],
                  response_format:{
                    type:"json_schema",
                    json_schema:{
                      name:"files_payload",
                      schema:{
                        type:"object",
                        additionalProperties:false,
                        required:["files"],
                        properties:{
                          files:{
                            type:"array",
                            items:{
                              type:"object",
                              additionalProperties:false,
                              required:["path","content"],
                              properties:{ path:{type:"string"}, content:{type:"string"} }
                            }
                          }
                        }
                      }
                    }
                  }
                }' > ai/request.files.json
            else
              system3=$'Output ONLY a compact JSON with exact key `files`: [{ "path": "relative/path", "content": "UTF-8 file content" }, ...]. No prose, no markdown, no trailing text.\nImplement the SPEC as WORKING CODE under ALLOWED_PATHS.'
              gen_req "$system3" "$PROMPT_FILE" "ai/request.files.json"
            fi

            for _ in 1 2 3; do
              if call_api_with_retry "ai/request.files.json" "ai/response.files.json"; then break
              else
                if [ "${ALLOW_JSON_SCHEMA}" != "1" ] || [ "${ENDPOINT##*/}" = "completions" ]; then
                  gen_req "$system3" "$PROMPT_FILE" "ai/request.files.json"
                fi
              fi
            done

            jq -r -f "ai/extract.jq" "ai/response.files.json" > "ai/out.files.txt"
            sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i "ai/out.files.txt" || true

            parse_ok=1; jq -e . "ai/out.files.txt" >/dev/null 2>&1 || parse_ok=0
            if [ $parse_ok -ne 1 ]; then
              echo "::warning::files JSON not parseable; attempting repair"
              cp "ai/out.files.txt" "ai/out.files.prev.txt"
              system4=$'You will receive an almost-JSON model output. Return ONLY strict JSON with the exact top-level key `files` (array of {path, content} strings). No prose.'
              for i in 1 2; do
                if [ "${ALLOW_JSON_SCHEMA}" = "1" ] && [ "${ENDPOINT##*/}" != "completions" ]; then
                  jq -n --arg model "$MODEL" --arg max "$MAX_OUT_TOKENS" --rawfile prev "ai/out.files.prev.txt" \
                    '{
                      model:$model,
                      max_output_tokens:($max|tonumber),
                      input:[
                        {"role":"system","content":[{"type":"input_text","text":"Fix to STRICT JSON using the schema; output only JSON."}]},
                        {"role":"user","content":[{"type":"input_text","text":$prev}]}
                      ],
                      response_format:{
                        type:"json_schema",
                        json_schema:{
                          name:"files_payload",
                          schema:{
                            type:"object",
                            additionalProperties:false,
                            required:["files"],
                            properties:{
                              files:{
                                type:"array",
                                items:{
                                  type:"object",
                                  additionalProperties:false,
                                  required:["path","content"],
                                  properties:{ path:{type:"string"}, content:{type:"string"} }
                                }
                              }
                            }
                          }
                        }
                      }
                    }' > ai/request.files.repair.json
                else
                  gen_req "$system4" "ai/out.files.prev.txt" "ai/request.files.repair.json"
                fi

                if call_api_with_retry "ai/request.files.repair.json" "ai/response.files.repair.json"; then
                  jq -r -f "ai/extract.jq" "ai/response.files.repair.json" > "ai/out.files.txt"
                  sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i "ai/out.files.txt" || true
                  jq -e . "ai/out.files.txt" >/dev/null 2>&1 && { parse_ok=1; break; }
                fi
              done
            fi

            if [ $parse_ok -ne 1 ]; then
              echo "::group::raw out.files (first 2KB)"
              head -c 2048 ai/out.files.txt | sed 's/^/RAW: /' || true
              echo "::endgroup::"
              echo "::error::Model did not return parseable JSON"; exit 7
            fi

            jq -c -f "ai/normalize.jq" "ai/out.files.txt" > "$FILES_JSON"
            if [ ! -s "$FILES_JSON" ] || ! jq -e 'type=="array" and length>0 and all(.[]; has("path") and has("content"))' "$FILES_JSON" >/dev/null; then
              echo "::error::Model did not return valid files JSON"; exit 7
            fi

            allow_all=0
            if [ -s "ai/allowed_paths.txt" ]; then mapfile -t ALLOWED < "ai/allowed_paths.txt"; else allow_all=1; fi
            jq -r '.[] | @base64' "$FILES_JSON" | while read -r row; do
              _jq(){ echo "$row" | base64 -d | jq -r "$1"; }
              p="$(_jq '.path')"; c="$(_jq '.content')"
              case "$p" in ai/*) echo "::warning::skip ai/: $p"; continue ;; esac
              if printf "%s" "$p" | grep -qiE '(COMPLIANCE|SECURITY|CODE_OF_CONDUCT|CONTRIBUTING|README)\.(md|txt|json)$'; then
                echo "::warning::skip non-code doc: $p"; continue
              fi
              ok="$allow_all"
              if [ "$allow_all" -ne 1 ]; then
                for pat in "${ALLOWED[@]}"; do
                  if [ "${p#"$pat"}" != "$p" ] || [ "$p" = "$pat" ]; then ok=1; break; fi
                done
              fi
              [ "$ok" -ne 1 ] && { echo "::warning::skip (not allowed): $p"; continue; }
              mkdir -p "$(dirname "$p")"; printf "%s" "$c" > "$p"; git add "$p"
            done
          fi

          if ! git diff --cached --name-only | grep -q "."; then
            echo "::error::No changes staged after all paths"; exit 6
          fi

          if ! git diff --cached --name-only | grep -E '\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|sh|conf|cfg)$|(^|/)\.htaccess$|(^|/)Dockerfile$|(^|/)Makefile$' >/dev/null; then
            echo "::error::No code files staged (only non-code docs). Aborting."; exit 6
          fi

          git commit -m "codex(init): seed from specs via ${OPENAI_MODEL}"

      - name: "Upload AI artifacts"
        if: "always()"
        uses: "actions/upload-artifact@v4"
        with:
          name: "ai-artifacts-${{ github.run_id }}"
          path: |
            ai/**
            !**/*.tmp

      - name: "Show summary"
        if: "always()"
        shell: "bash"
        run: |
          echo "Branch created: $(git branch --show-current)"
          echo "Seed files:"
          git show --name-only --pretty="" HEAD || true
