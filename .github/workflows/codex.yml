name: "Codex"

on:
  workflow_dispatch: {}

permissions:
  contents: "write"

jobs:
  generate:
    name: "Generate from specs (full → branch)"
    runs-on: "ubuntu-24.04"

    env:
      SPEC_ROOT: "spec"
      SPEC_DIRS: "env features foundation fountation tests"
      PROMPT_FILE: "ai/prompt.md"
      PATCH_FILE: "ai/patch.diff"
      OPENAI_MODEL: "gpt-5-codex"
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      OPENAI_BASE_URL: "${{ secrets.OPENAI_BASE_URL }}"
      BRANCH_PREFIX: "codex/autogen"

    steps:
      - name: "Checkout main"
        uses: "actions/checkout@v4"
        with:
          ref: "main"
          fetch-depth: "1"
          set-safe-directory: "true"

      - name: "Preflight"
        shell: "bash"
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is not set"
            exit 1
          fi
          mkdir -p "ai"

      - name: "Compose prompt (full) from specs"
        id: "compose"
        shell: "bash"
        run: |
          set -euo pipefail
          : > "ai/allowed_paths.txt"
          : > "$PROMPT_FILE"

          LANG_HINT=""

          # 1) 明示キー
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E "^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*" "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E "s/.*[:=]\s*//; s/[\",]//g; s/\s+$//;" | tr "A-Z" "a-z")"
              break
            fi
          done

          # 2) env/policies.md の自由記述
          if [ -z "$LANG_HINT" ] && [ -f "${SPEC_ROOT}/env/policies.md" ]; then
            line="$(grep -i -m1 -E "\b(php|typescript|javascript|node\.js|python|golang|go|ruby|java|c#|\.net)\b" "${SPEC_ROOT}/env/policies.md" || true)"
            if   printf "%s" "$line" | grep -qi "\bphp\b"; then LANG_HINT="php"
            elif printf "%s" "$line" | grep -qi "\btypescript|javascript|node\.js\b"; then LANG_HINT="typescript"
            elif printf "%s" "$line" | grep -qi "\bpython\b"; then LANG_HINT="python"
            elif printf "%s" "$line" | grep -qi "\bgolang\b|\b go \b"; then LANG_HINT="go"
            elif printf "%s" "$line" | grep -qi "\bruby\b"; then LANG_HINT="ruby"
            elif printf "%s" "$line" | grep -qi "\bjava\b"; then LANG_HINT="java"
            elif printf "%s" "$line" | grep -qi "\bc#|\.net\b"; then LANG_HINT="csharp"
            fi
          fi

          # 3) 最後の保険
          if [ -z "$LANG_HINT" ]; then
            t="$(grep -R -h -i -E "\b(php|typescript|javascript|node\.js|python|golang|go|ruby|java|c#|\.net)\b" \
                 "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" 2>/dev/null | head -n1 || true)"
            if   printf "%s" "$t" | grep -qi "php"; then LANG_HINT="php"
            elif printf "%s" "$t" | grep -qi "typescript\|javascript\|node\.js"; then LANG_HINT="typescript"
            elif printf "%s" "$t" | grep -qi "python"; then LANG_HINT="python"
            elif printf "%s" "$t" | grep -qi "golang\|[^a-zA-Z]go[^a-zA-Z]"; then LANG_HINT="go"
            elif printf "%s" "$t" | grep -qi "ruby"; then LANG_HINT="ruby"
            elif printf "%s" "$t" | grep -qi "java"; then LANG_HINT="java"
            elif printf "%s" "$t" | grep -qi "c#\|\.net"; then LANG_HINT="csharp"
            fi
          fi

          case "${LANG_HINT:-}" in
            php*|composer*|psr*)              LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*)                        LANG_HINT="python" ;;
            go|golang*)                        LANG_HINT="go" ;;
            ruby*)                             LANG_HINT="ruby" ;;
            java*)                             LANG_HINT="java" ;;
            c#|dotnet*|.net*|cs)              LANG_HINT="csharp" ;;
            "" )                               LANG_HINT="auto" ;;
          esac

          echo "Language from env-spec: ${LANG_HINT}"

          # allowed paths
          grep -R -n -E "(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+\.[A-Za-z0-9]+)" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" \
            | grep -E "[/A-Za-z0-9_.-]+\.[A-Za-z0-9]+" >> "ai/allowed_paths.txt" || true

          grep -R -h -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)" "$SPEC_ROOT" \
            | grep -o -E "[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)" >> "ai/allowed_paths.txt" || true

          grep -R -h -E "(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?" "$SPEC_ROOT" \
            | sed -E "s/.*:\s*//; s/[\"']//g" | awk "{gsub(/\/?$/,\"/\");print}" >> "ai/allowed_paths.txt" || true

          sed -E "s#^\./##; s#//+#/#g" -i "ai/allowed_paths.txt" || true
          LC_ALL=C sort -u "ai/allowed_paths.txt" -o "ai/allowed_paths.txt"

          # プロンプト
          printf "%s\n" "# Codex generation prompt" >> "$PROMPT_FILE"
          printf "\n## LANGUAGE (MUST)\n\n" >> "$PROMPT_FILE"
          printf "language: %s\n" "$LANG_HINT" >> "$PROMPT_FILE"

          printf "\n## ALLOWED_PATHS (only modify/create under these)\n\n" >> "$PROMPT_FILE"
          if [ -s "ai/allowed_paths.txt" ]; then
            while IFS= read -r line; do
              printf -- "- %s\n" "$line" >> "$PROMPT_FILE"
            done < "ai/allowed_paths.txt"
          else
            printf -- "- (empty)\n" >> "$PROMPT_FILE"
            printf "\nWhen empty, infer exact file paths from the spec text. Do NOT invent arbitrary names unrelated to the spec.\n" >> "$PROMPT_FILE"
          fi

          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e "s/\r$//" "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

          {
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Output ONE unified diff (UTF-8), repository-rooted; no prose, no code fences.\n"
            printf -- "- Follow LANGUAGE. Respect ALLOWED_PATHS strictly.\n"
            printf -- "- The diff MUST contain real code lines, not placeholders.\n"
            printf -- "- If initial attempt fails, SYNTHESIZE a complete diff that fulfills the spec.\n"
          } >> "$PROMPT_FILE"

          echo "LANG_HINT=${LANG_HINT}" >> "$GITHUB_OUTPUT"

      - name: "Generate unified diff, commit to new branch, push"
        id: "gen"
        shell: "bash"
        run: |
          set -euo pipefail

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          MODEL="${OPENAI_MODEL}"
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
          ENDPOINT="${BASE%/}/v1/responses"

          BRANCH_NAME="${BRANCH_PREFIX}-${GITHUB_RUN_ID}"
          git checkout -b "${BRANCH_NAME}"

          extract_text () {
            local src="$1"
            local out="$2"
            local EXTRACT='[
              .output_text,
              ( try(.output | (if type=="array" then . else [] end)
                   | map( if has("content")
                            then (.content | (if type=="array" then map(.text // .string // .content // "") else . end)
                                       | (if type=="array" then join("") else (. // "") end))
                            else (.text // .content // "") end)
                   | join("")) catch empty )
            ] | map(select(type=="string" and . != "")) | .[0] // ""'
            jq -r "$EXTRACT" "$src" > "$out"
            sed -E -e "1{/^```[a-zA-Z-]*[[:space:]]*$/d;}" -e '${/^```[[:space:]]*$/d;}' -i "$out" || true
          }

          make_request () {
            local sys="$1"
            local src="$2"
            local dst="$3"
            jq -n --arg model "$MODEL" --arg sys "$sys" --rawfile prompt "$src" \
              '{ "model":$model, "max_output_tokens":4096,
                 "input":[ {"role":"system","content":[{"type":"input_text","text":$sys}]},
                           {"role":"user",  "content":[{"type":"input_text","text":$prompt}]} ] }' > "$dst"
          }

          is_unified () {
            local f="$1"
            grep -Eq "^(diff --git|--- a/)" "$f" && grep -Eq "(^\+\+\+ b/|^diff --git)" "$f"
          }

          # 1st call
          make_request "Output only a repository-rooted unified diff; no prose." "$PROMPT_FILE" "ai/request.json"
          resp_with_code="$(mktemp)"
          curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
               -w "\n%{http_code}\n" -d @ai/request.json "$ENDPOINT" | tee "$resp_with_code" >/dev/null
          status="$(tail -n1 "$resp_with_code")"
          head -n -1 "$resp_with_code" > "ai/response.json"
          rm -f "$resp_with_code"
          [ "$status" -lt 300 ] || { echo "::error::OpenAI error ${status}"; exit 3; }
          extract_text "ai/response.json" "ai/out.txt"
          awk "f||/^(diff --git|--- a\\/)/{f=1; print}" "ai/out.txt" > "$PATCH_FILE" || true

          # up to 2 repairs
          if ! is_unified "$PATCH_FILE"; then
            echo "::warning::first attempt not a unified diff; repairing"
            head -c 15000 "ai/out.txt" > "ai/out.trim.txt" || true
            for i in 1 2; do
              make_request "Extract ONLY the diff if present; otherwise SYNTHESIZE a complete unified diff that fulfills the spec. No prose." "ai/out.trim.txt" "ai/request.repair.json"
              r_with_code="$(mktemp)"
              curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                   -w "\n%{http_code}\n" -d @ai/request.repair.json "$ENDPOINT" | tee "$r_with_code" >/dev/null
              rstatus="$(tail -n1 "$r_with_code")"
              head -n -1 "$r_with_code" > "ai/response.repair.json"
              rm -f "$r_with_code"
              [ "$rstatus" -lt 300 ] || { echo "::error::repair call error ${rstatus}"; exit 3; }
              extract_text "ai/response.repair.json" "ai/out.repair.txt"
              awk "f||/^(diff --git|--- a\\/)/{f=1; print}" "ai/out.repair.txt" > "$PATCH_FILE" || true
              is_unified "$PATCH_FILE" && break
            done
          fi

          if ! is_unified "$PATCH_FILE"; then
            echo "::error::Model did not return a unified diff after retries"
            exit 4
          fi

          # apply
          if git apply --check "$PATCH_FILE"; then
            git apply --index --whitespace=fix "$PATCH_FILE"
          else
            echo "::warning::git apply check failed; attempting 3-way merge"
            git apply --3way --index --whitespace=fix "$PATCH_FILE" || true
          fi

          if ! git diff --cached --name-only | grep -q "."; then
            echo "::error::No staged changes after applying diff"
            exit 6
          fi

          git commit -m "codex(full): generated from specs via ${MODEL}"
          git push origin "HEAD:${BRANCH_NAME}"

          echo "branch=${BRANCH_NAME}" >> "$GITHUB_OUTPUT"
          echo "Generated branch: ${BRANCH_NAME}"

      - name: "Upload AI artifacts"
        uses: "actions/upload-artifact@v4"
        with:
          name: "ai-artifacts"
          if-no-files-found: "ignore"
          path: |
            ai/prompt.md
            ai/allowed_paths.txt
            ai/request.json
            ai/response.json
            ai/out.txt
            ai/request.repair.json
            ai/response.repair.json
            ai/out.repair.txt
            ai/patch.diff
