name: "codex"

on:
  workflow_dispatch: {}

permissions:
  contents: "read"

concurrency:
  group: "codex-generate"
  cancel-in-progress: true

jobs:
  generate:
    name: "generate"
    runs-on: "ubuntu-24.04"
    timeout-minutes: 30
    env:
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      OPENAI_MODEL: "gpt-5-codex"
      ENDPOINT: "https://api.openai.com/v1/responses"
      SPEC_ROOT: "spec"
      SPEC_DIRS: "env foundation features tests"
      PROMPT_FILE: "ai/prompt.md"
      REQUEST_JSON: "ai/request.json"
      RESPONSE_JSON: "ai/response.json"
      OUT_JSON: "ai/out.files.json"
      STAGING_DIR: "codex_out"
      CURL_TIMEOUT: "300"
      CURL_RETRIES: "5"
      CURL_RETRY_DELAY: "5"
      TITLE: "Codex generation prompt"

    steps:
      - name: "Checkout"
        uses: "actions/checkout@v4"
        with:
          persist-credentials: "false"
          fetch-depth: 1

      - name: "Install jq and coreutils"
        shell: "bash"
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq coreutils

      - name: "Build prompt"
        shell: "bash"
        run: |
          set -euo pipefail
          mkdir -p "ai"
          : > "$PROMPT_FILE"
          {
            printf "# %s\n\n" "$TITLE"
            printf "## STRICT RULES\n\n"
            printf -- "- Return ONLY JSON (no prose) that matches {\"files\":[{\"path\":string,\"content\":string},...]}.\n"
            printf -- "- Implement runnable APPLICATION CODE and TESTS.\n"
            printf -- "- Emit at least one code file under \"/src\" or \"/app\".\n"
            printf -- "- You may also emit build files: \"package.json\", \"tsconfig.json\", \"pyproject.toml\", \"requirements.txt\", \"composer.json\", \"go.mod\".\n"
            printf -- "- Do NOT create policy/compliance/README/meta docs.\n"
            printf -- "- NEVER write under the \"ai/\" directory.\n\n"
            printf "## SPEC CONTENT\n"
          } >> "$PROMPT_FILE"
          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \
              \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true
          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e 's/\r$//' "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

      - name: "Call Responses API"
        shell: "bash"
        run: |
          set -euo pipefail
          jq -n \
            --arg model "$OPENAI_MODEL" \
            --rawfile prompt "$PROMPT_FILE" \
            --argjson max_out "${MAX_TOKENS:-0}" \
            '{
               "model": $model,
               "temperature": 0,
               "response_format": {
                 "type": "json_schema",
                 "json_schema": {
                   "name": "emit_files",
                   "strict": true,
                   "schema": {
                     "type": "object",
                     "additionalProperties": false,
                     "required": ["files"],
                     "properties": {
                       "files": {
                         "type": "array",
                         "minItems": 1,
                         "items": {
                           "type": "object",
                           "additionalProperties": false,
                           "required": ["path","content"],
                           "properties": {
                             "path": { "type": "string", "minLength": 1 },
                             "content": { "type": "string" }
                           }
                         }
                       }
                     }
                   }
                 }
               },
               "input": [
                 {
                   "role": "system",
                   "content": [
                     {
                       "type": "input_text",
                       "text": "You are Codex. Output ONLY a JSON object with the exact shape {\\\"files\\\":[{\\\"path\\\":string,\\\"content\\\":string},...]}. No prose, no code fences. Write full, runnable code. No placeholders. Never write inside ai/."
                     }
                   ]
                 },
                 {
                   "role": "user",
                   "content": [
                     {
                       "type": "input_text",
                       "text": ("Implement the SPEC as runnable application code and tests. Return files to write as JSON only.\n\n" + $prompt)
                     }
                   ]
                 }
               ]
             }
             | if $max_out > 0 then . + { "max_output_tokens": $max_out } else . end' > "$REQUEST_JSON"

          curl --fail-with-body -sS --connect-timeout 30 --max-time "$CURL_TIMEOUT" \
            --retry "$CURL_RETRIES" --retry-all-errors --retry-delay "$CURL_RETRY_DELAY" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @"$REQUEST_JSON" "$ENDPOINT" \
            | tee "$RESPONSE_JSON" >/dev/null

          jq -e -r '
            (.output[]?.content[]? | select(.type=="output_text") | .text)
            // (.output_text)
            // (.response)
          ' "$RESPONSE_JSON" | jq -e '.' > "$OUT_JSON"

      - name: "Stage outputs to separate folder (no repo changes)"
        shell: "bash"
        run: |
          set -euo pipefail
          rm -rf "$STAGING_DIR"
          mkdir -p "$STAGING_DIR"
          jq -r '.files[] | @base64' "$OUT_JSON" | while read -r row; do
            _jq(){ echo "$row" | base64 -d | jq -r "$1"; }
            path="$(_jq ".path")"
            content="$(_jq ".content")"
            case "$path" in
              ai/*) echo "::warning::skip ai/: ${path}"; continue ;;
            esac
            mkdir -p "$STAGING_DIR/$(dirname "$path")"
            printf "%s" "$content" > "$STAGING_DIR/$path"
          done
          echo "STAGED_PATHS=$(jq -r '.files[].path' "$OUT_JSON" | paste -sd "," -)" >> "$GITHUB_ENV"

      - name: "Upload generated files"
        uses: "actions/upload-artifact@v4"
        with:
          name: "codex-generated-files"
          path: |
            ${{ env.STAGING_DIR }}/**
            ${{ env.OUT_JSON }}
            ${{ env.REQUEST_JSON }}
            ${{ env.RESPONSE_JSON }}
