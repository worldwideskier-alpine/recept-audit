name: "Codex"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "実行モード: full(全生成) / incremental(差分)"
        required: false
        default: "full"
        type: choice
        options: ["full", "incremental"]
      model:
        description: "OpenAI モデル名 (例: gpt-5-codex / gpt-5 / gpt-4.1 / gpt-4o-mini)"
        required: false
        default: ""
        type: string

  push:
    branches: ["main"]
    paths:
      - "spec/**"

permissions:
  contents: write
  pull-requests: write

jobs:
  generate:
    # push時にコミットメッセージへ [skip-codex] を含めると起動をスキップ
    if: ${{ github.event_name != 'push' || !contains(github.event.head_commit.message, '[skip-codex]') }}
    runs-on: ubuntu-latest

    env:
      SPEC_ROOT: "spec"
      SPEC_DIRS: "foundation env-profiles features tests"
      PROMPT_FILE: "ai/prompt.md"
      PATCH_FILE: "ai/patch.diff"
      MODEL_DEFAULT: "gpt-4o-mini"
      OPENAI_MODEL: "${{ inputs.model }}"
      MODE: "${{ inputs.mode }}"
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      OPENAI_BASE_URL: "${{ vars.OPENAI_BASE_URL }}"

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup Node (cache if lock exists)"
        if: ${{ hashFiles('**/package-lock.json', '**/npm-shrinkwrap.json', '**/yarn.lock') != '' }}
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: "Setup Node (no cache)"
        if: ${{ hashFiles('**/package-lock.json', '**/npm-shrinkwrap.json', '**/yarn.lock') == '' }}
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: "Preflight: API key"
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is not set"
            exit 1
          fi
          mkdir -p ai

      - name: "Compose prompt from spec (no-heredoc)"
        shell: bash
        run: |
          set -euo pipefail
          : > "$PROMPT_FILE"
          printf "%s\n" "# Codex generation prompt" >> "$PROMPT_FILE"
          printf "%s\n" "" >> "$PROMPT_FILE"
          printf "%s\n" "## Mode: ${MODE}" >> "$PROMPT_FILE"
          printf "%s\n" "" >> "$PROMPT_FILE"

          # MODE=incremental のとき spec/ の変更ファイルのみ（なければ全文）
          tmp_list="$(mktemp)"
          if [ "${MODE:-full}" = "incremental" ]; then
            git fetch --depth=50 origin || true
            git diff --name-only --diff-filter=AMR origin/main...HEAD -- "${SPEC_ROOT}/" \
              | grep -E '\.(md|txt|ya?ml|json)$' >> "$tmp_list" || true
          fi
          if [ ! -s "$tmp_list" ]; then
            for d in $SPEC_DIRS; do
              if [ -d "${SPEC_ROOT}/${d}" ]; then
                find "${SPEC_ROOT}/${d}" -type f \
                  \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) \
                  >> "$tmp_list"
              fi
            done
          fi

          if [ -s "$tmp_list" ]; then
            LC_ALL=C sort "$tmp_list" -o "$tmp_list"
            while IFS= read -r f; do
              printf "%s\n" "" >> "$PROMPT_FILE"
              printf "%s\n" "### $(basename "$f")" >> "$PROMPT_FILE"
              printf "%s\n" "" >> "$PROMPT_FILE"
              sed -e 's/\r$//' "$f" >> "$PROMPT_FILE"
              printf "%s\n" "" >> "$PROMPT_FILE"
            done < "$tmp_list"
          fi
          rm -f "$tmp_list"

          {
            printf "\n## OUTPUT CONTRACT (MUST)\n\n"
            printf -- "- Return a single Unified Diff patch rooted at the repository.\n"
            printf -- "- No prose, no explanations, no code fences, no headings.\n"
            printf -- "- Start with either 'diff --git' lines or with '--- a/' then '+++ b/'.\n"
            printf -- "- If unsure or no change is needed, emit exactly this no-op patch:\n\n"
            printf -- "--- a/ai/.noop\n"
            printf -- "+++ b/ai/.noop\n"
            printf -- "@@ -1 +1 @@\n"
            printf -- "-placeholder\n"
            printf -- "+placeholder\n"
          } >> "$PROMPT_FILE"

      - name: "Call OpenAI (curl + jq, no heredoc) — auto route with retry"
        id: call
        shell: bash
        run: |
          set -euo pipefail

          is_patch() { grep -Eq '^(diff --git|--- a/)' "$1" && grep -Eq '(^\+\+\+ b/|^diff --git)' "$1"; }
          write_noop() {
            : > "$PATCH_FILE"
            printf "%s\n" "--- a/ai/.noop"   >> "$PATCH_FILE"
            printf "%s\n" "+++ b/ai/.noop"   >> "$PATCH_FILE"
            printf "%s\n" "@@ -1 +1 @@"     >> "$PATCH_FILE"
            printf "%s\n" "-placeholder"    >> "$PATCH_FILE"
            printf "%s\n" "+placeholder"    >> "$PATCH_FILE"
          }

          # 有効モデル名
          _in="${OPENAI_MODEL:-}"
          MODEL="$MODEL_DEFAULT"
          if [ -n "$_in" ]; then
            case "$_in" in gpt-*|o* ) MODEL="$_in" ;; * ) echo "note: unknown model '$_in' -> fallback to $MODEL_DEFAULT" ;; esac
          fi
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
          echo "Using model: $MODEL"
          echo "Base URL  : $BASE"

          # 共通 system 契約
          SYSTEM_CONTRACT=$'You are a patch generator.\nMUST return ONLY a unified diff (UTF-8) rooted at repository.\nNo explanations, no prose, no code fences.\nIf unable, return exactly this no-op patch:\n--- a/ai/.noop\n+++ b/ai/.noop\n@@ -1 +1 @@\n-placeholder\n+placeholder'

          # ---- リクエスト作成（Responses: temperature を送らない）----
          if printf "%s" "$MODEL" | grep -qiE '^gpt-5-codex( |$|-|:)'; then
            jq -n --arg model "$MODEL" --arg sys "$SYSTEM_CONTRACT" --rawfile prompt "$PROMPT_FILE" \
              '{
                 model: $model,
                 max_output_tokens: 4096,
                 input: [
                   { role: "system", content: [ { type: "input_text", text: $sys } ] },
                   { role: "user",   content: [ { type: "input_text", text: $prompt } ] }
                 ]
               }' > ai/request.json
            ENDPOINT="${BASE%/}/v1/responses"
            EXTRACT_FILTER='( .output_text ) // ( ( .output // [] ) | select(type=="array") | map( if type=="string" then . else (.text // .content // "") end ) | join("") )'
          else
            jq -n --arg model "$MODEL" --arg sys "$SYSTEM_CONTRACT" --rawfile prompt "$PROMPT_FILE" \
              '{
                 model: $model, temperature: 0, max_tokens: 4096,
                 messages: [ { role: "system", content: $sys }, { role: "user", content: $prompt } ]
               }' > ai/request.json
            ENDPOINT="${BASE%/}/v1/chat/completions"
            EXTRACT_FILTER='( .choices[0].message.content // .choices[0].text // "" )'
          fi

          # ---- 1st call ----
          resp_with_code="$(mktemp)"
          curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
               -w "\n%{http_code}\n" -d @ai/request.json "$ENDPOINT" | tee "$resp_with_code" >/dev/null
          status="$(tail -n1 "$resp_with_code")"; head -n -1 "$resp_with_code" > ai/response.json; rm -f "$resp_with_code"
          if [ "${status}" -ge 300 ]; then
            echo "::error::OpenAI error ${status}"; head -c 800 ai/request.json; echo; cat ai/response.json || true; exit 3
          fi

          jq -r "${EXTRACT_FILTER}" ai/response.json > ai/out.txt
          sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i ai/out.txt || true
          awk 'f||/^(diff --git|--- a\/)/{f=1; print}' ai/out.txt > "$PATCH_FILE"

          if is_patch "$PATCH_FILE"; then
            echo "patch verified"
          else
            echo "::warning::first attempt was not a unified diff; retrying with repair prompt"
            head -c 15000 ai/out.txt > ai/out.trim.txt || true

            REPAIR_SYS=$'You will be given some text.\nIf it already contains a unified diff, extract ONLY the diff.\nOtherwise, output exactly this no-op patch:\n--- a/ai/.noop\n+++ b/ai/.noop\n@@ -1 +1 @@\n-placeholder\n+placeholder'

            if printf "%s" "$MODEL" | grep -qiE '^gpt-5-codex( |$|-|:)'; then
              jq -n --arg model "$MODEL" --arg sys "$REPAIR_SYS" --rawfile prev ai/out.trim.txt \
                '{ model: $model, max_output_tokens: 4096,
                   input: [ { role:"system",content:[{type:"input_text",text:$sys}] },
                            { role:"user",  content:[{type:"input_text",text:$prev}] } ] }' > ai/request.repair.json
            else
              jq -n --arg model "$MODEL" --arg sys "$REPAIR_SYS" --rawfile prev ai/out.trim.txt \
                '{ model: $model, temperature: 0, max_tokens: 2048,
                   messages: [ { role:"system",content:$sys }, { role:"user",content:$prev } ] }' > ai/request.repair.json
            fi

            resp_with_code="$(mktemp)"
            curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                 -w "\n%{http_code}\n" -d @ai/request.repair.json "$ENDPOINT" | tee "$resp_with_code" >/dev/null
            status="$(tail -n1 "$resp_with_code")"; head -n -1 "$resp_with_code" > ai/response.repair.json; rm -f "$resp_with_code"
            if [ "${status}" -ge 300 ]; then
              echo "::warning::repair call error ${status} — fallback to local no-op"; \
              : > ai/out.repair.txt; \
              { echo "--- a/ai/.noop"; echo "+++ b/ai/.noop"; echo "@@ -1 +1 @@"; echo "-placeholder"; echo "+placeholder"; } > "$PATCH_FILE"
            else
              jq -r "${EXTRACT_FILTER}" ai/response.repair.json > ai/out.repair.txt
              sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i ai/out.repair.txt || true
              awk 'f||/^(diff --git|--- a\/)/{f=1; print}' ai/out.repair.txt > "$PATCH_FILE" || true
              if ! grep -Eq '^(diff --git|--- a/)' "$PATCH_FILE"; then
                { echo "--- a/ai/.noop"; echo "+++ b/ai/.noop"; echo "@@ -1 +1 @@";
                  echo "-placeholder"; echo "+placeholder"; } > "$PATCH_FILE"
              fi
            fi

            echo "patch verified (after repair or fallback)"
          fi

      # ---------- ここから：パッチ適用 → PR 作成 ----------

      - name: "Detect no-op patch"
        id: noop
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f "$PATCH_FILE" ]; then
            echo "is_noop=true" >> "$GITHUB_OUTPUT"; exit 0
          fi
          others=$(grep -E '^(diff --git a/|--- a/)' "$PATCH_FILE" | grep -v 'ai/.noop' | wc -l || true)
          if [ "$others" -eq 0 ]; then
            echo "is_noop=true" >> "$GITHUB_OUTPUT"
            echo "Detected no-op patch; PR will be skipped."
          else
            echo "is_noop=false" >> "$GITHUB_OUTPUT"
          fi

      - name: "Apply patch to working tree"
        if: ${{ steps.noop.outputs.is_noop != 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          # 実際のファイルへ反映（インデックスは後段アクションが面倒見ます）
          git apply --whitespace=fix "$PATCH_FILE"
          if git diff --quiet; then
            echo "No changes after applying patch."; exit 78 # neutral
          fi

      - name: "Create Pull Request"
        if: ${{ steps.noop.outputs.is_noop != 'true' }}
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Codex: generate from specs (mode=${{ env.MODE }}, model=${{ env.OPENAI_MODEL != '' && env.OPENAI_MODEL || env.MODEL_DEFAULT }})"
          body: |
            This PR was created automatically by Codex workflow.
            - Mode: `${{ env.MODE }}`
            - Model: `${{ env.OPENAI_MODEL != '' && env.OPENAI_MODEL || env.MODEL_DEFAULT }}`
            - Source: `spec/` (foundation / env-profiles / features / tests)
          branch: "codex/autogen-${{ github.run_id }}"
          base: "main"
          delete-branch: true
          labels: "codex, automation"

      - name: "Note: PR skipped (no-op)"
        if: ${{ steps.noop.outputs.is_noop == 'true' }}
        run: echo "PR skipped because the generated patch was a no-op."

      # ---------- ここまで：適用 → PR 作成 ----------

      - name: "Upload response debug (if any)"
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: "ai-response-debug"
          path: |
            ai/request.json
            ai/response.json
            ai/out.txt
            ai/request.repair.json
            ai/response.repair.json
            ai/out.repair.txt
          if-no-files-found: ignore

      - name: "Upload prompt & patch (always)"
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: "ai-prompt-and-patch"
          path: |
            ai/prompt.md
            ai/patch.diff
          if-no-files-found: ignore
