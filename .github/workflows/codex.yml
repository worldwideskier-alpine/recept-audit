name: "Codex"

on:
  workflow_dispatch: {}
  push:
    branches: ["main"]
    paths:
      - "spec/**"

permissions:
  contents: write
  pull-requests: write

jobs:
  generate:
    name: "Generate from specs"
    runs-on: ubuntu-latest

    env:
      # ── 仕様の場所 ───────────────────────────────────────────────
      SPEC_ROOT: "spec"
      SPEC_DIRS: "env features foundation fountation tests" # 実在ディレクトリに合わせる
      # ── 一時/出力 ───────────────────────────────────────────────
      PROMPT_FILE: "ai/prompt.md"
      PATCH_FILE:  "ai/patch.diff"
      GEN_OUTPUT_DIR: "generated"
      # ── モデル固定（full/差分なし） ─────────────────────────────
      MODEL_DEFAULT: "gpt-4o-mini"     # 保険（未使用想定）
      OPENAI_MODEL:  "gpt-5-codex"
      MODE:          "full"
      # ── OpenAI ─────────────────────────────────────────────────
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      OPENAI_BASE_URL: ""  # 企業プロキシ等を使う場合はここに https://xxx を入れる

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Preflight: API key"
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is not set"
            exit 1
          fi
          mkdir -p ai "$GEN_OUTPUT_DIR"

      - name: "Compose prompt from spec (no-heredoc)"
        id: compose
        shell: bash
        run: |
          set -euo pipefail
          : > "$PROMPT_FILE"
          : > ai/allowed_paths.txt

          # --- 言語検出（キー定義 → 自由記述ヒューリスティック） ---
          LANG_HINT=""

          # 1) language:, runtime.language:, lang:, stack.language:, runtime:
          for root in "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" "${SPEC_ROOT}"; do
            [ -d "$root" ] || continue
            hit="$(grep -R -n -i -E '^\s*(language|runtime\.language|lang|stack\.language|runtime)\s*[:=]\s*' "$root" 2>/dev/null | head -n1 || true)"
            if [ -n "$hit" ]; then
              LANG_HINT="$(printf "%s" "$hit" | sed -E 's/.*[:=]\s*//; s/[",]//g; s/\s+$//;' | tr 'A-Z' 'a-z')"
              break
            fi
          done

          # 2) 自由記述（例: "PHP 8.3（…）" 等）を緩く検出
          if [ -z "$LANG_HINT" ]; then
            t="$(grep -R -h -i -E '\b(php|typescript|javascript|node\.js|python|golang|go|ruby|java|c#|\.net)\b' \
                 "${SPEC_ROOT}/env" "${SPEC_ROOT}/foundation" "${SPEC_ROOT}/fountation" 2>/dev/null | head -n1 || true)"
            case "$t" in
              *php* ) LANG_HINT="php" ;;
              *typescript*|*javascript*|*node.js*|*node\ * ) LANG_HINT="typescript" ;;
              *python* ) LANG_HINT="python" ;;
              *golang*|*" go "*|go[^a-zA-Z]* ) LANG_HINT="go" ;;
              *ruby* ) LANG_HINT="ruby" ;;
              *java* ) LANG_HINT="java" ;;
              *c#*|*.net* ) LANG_HINT="csharp" ;;
            esac
          fi

          # 3) 正規化
          case "${LANG_HINT:-}" in
            php*|composer*|psr*)              LANG_HINT="php" ;;
            ts|typescript*|node*|javascript*) LANG_HINT="typescript" ;;
            py|python*)                        LANG_HINT="python" ;;
            go|golang*)                        LANG_HINT="go" ;;
            ruby*)                             LANG_HINT="ruby" ;;
            java*)                             LANG_HINT="java" ;;
            c#|dotnet*|.net*|cs)              LANG_HINT="csharp" ;;
            "" )                               LANG_HINT="auto" ;;
          esac

          if [ "$LANG_HINT" = "auto" ]; then
            echo "::warning::Language not found in environment specs; using 'auto'."
          else
            echo "Language from env-spec: ${LANG_HINT}"
          fi

          # --- ALLOWED_PATHS（仕様が明示する出力/作成先の抽出） ---
          # file/path/destination/output: xxx.ext
          grep -R -n -E '(^|\s)(file|path|destination|output|生成先|出力先)\s*:\s*([A-Za-z0-9_./-]+\.[A-Za-z0-9]+)' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\'']//g' \
            | grep -E '[/A-Za-z0-9_.-]+\.[A-Za-z0-9]+' >> ai/allowed_paths.txt || true

          # 文面中の明示的なファイル拡張子も拾っておく（保守的）
          grep -R -h -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)' "$SPEC_ROOT" \
            | grep -o -E '[/A-Za-z0-9_.-]+\.(php|ts|tsx|js|jsx|py|rb|go|java|cs|sql|html|css|yml|yaml|json|ini|xml)' \
            >> ai/allowed_paths.txt || true

          # ディレクトリ系
          grep -R -h -E '(^|\s)(dir|directory|folder|ディレクトリ)\s*:\s*[A-Za-z0-9_./-]+/?' "$SPEC_ROOT" \
            | sed -E 's/.*:\s*//; s/["'\'']//g' | awk '{gsub(/\/?$/,"/");print}' >> ai/allowed_paths.txt || true

          sed -E 's#^\./##; s#//+#/#g' -i ai/allowed_paths.txt || true
          LC_ALL=C sort -u ai/allowed_paths.txt -o ai/allowed_paths.txt

          # --- プロンプト本文 ---
          printf "%s\n" "# Codex generation prompt" >> "$PROMPT_FILE"
          printf "\n## LANGUAGE (MUST)\n\n" >> "$PROMPT_FILE"
          printf "language: %s\n" "$LANG_HINT" >> "$PROMPT_FILE"

          if [ -s ai/allowed_paths.txt ]; then
            printf "\n## ALLOWED_PATHS (only modify/create under these)\n\n" >> "$PROMPT_FILE"
            awk '{print "- " $0}' ai/allowed_paths.txt >> "$PROMPT_FILE"
          else
            printf "\n## ALLOWED_PATHS\n\n- (empty)\n" >> "$PROMPT_FILE"
            printf "\n(When empty, infer exact paths from the spec. Do NOT invent arbitrary files such as 'generated/app.php' unless explicitly named.)\n" >> "$PROMPT_FILE"
          fi

          # spec本文を結合（長過ぎ対策で各ファイル先頭 4000 行まで）
          tmp_list="$(mktemp)"
          for d in $SPEC_DIRS; do
            [ -d "${SPEC_ROOT}/${d}" ] || continue
            find "${SPEC_ROOT}/${d}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) \
              >> "$tmp_list"
          done
          LC_ALL=C sort -o "$tmp_list" "$tmp_list" || true

          while IFS= read -r f; do
            printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
            sed -e 's/\r$//' "$f" | head -n 4000 >> "$PROMPT_FILE"
          done < "$tmp_list"
          rm -f "$tmp_list"

          {
            printf "\n## STRICT OUTPUT RULES\n\n"
            printf -- "- Return ONE unified diff (UTF-8), repository-rooted; no prose, no code fences.\n"
            printf -- "- Respect LANGUAGE above. Implement in that primary language unless the spec explicitly says otherwise for a file.\n"
            printf -- "- When ALLOWED_PATHS is non-empty, modify/create files **only** under those paths. Otherwise, use the exact paths named in the spec; do NOT invent filenames.\n"
            printf -- "- If the spec requests deletions/renames/moves, encode them in the diff.\n"
          } >> "$PROMPT_FILE"

          echo "LANG_HINT=${LANG_HINT}" >> "$GITHUB_OUTPUT"

      - name: "Call OpenAI (curl + jq, no heredoc) — auto route with retry"
        shell: bash
        run: |
          set -euo pipefail

          is_patch(){ grep -Eq '^(diff --git|--- a/)' "$1" && grep -Eq '(^\+\+\+ b/|^diff --git)' "$1"; }

          MODEL="${OPENAI_MODEL:-gpt-5-codex}"
          BASE="${OPENAI_BASE_URL:-https://api.openai.com}"
          echo "Using model: $MODEL"
          echo "Base: $BASE"

          SYSTEM_CONTRACT="You output only a unified diff. Follow LANGUAGE and ALLOWED_PATHS strictly; do not create files not named in the spec."

          # gpt-5-codex は Responses API (input[]) / それ以外は Chat Completions
          if printf "%s" "$MODEL" | grep -qiE '^gpt-5-codex( |$|-|:)'; then
            jq -n --arg model "$MODEL" --arg sys "$SYSTEM_CONTRACT" --rawfile prompt "$PROMPT_FILE" \
              '{ model:$model, max_output_tokens:4096,
                 input:[ {role:"system",content:[{type:"input_text",text:$sys}]},
                         {role:"user",  content:[{type:"input_text",text:$prompt}]} ] }' > ai/request.json
            ENDPOINT="${BASE%/}/v1/responses"
          else
            jq -n --arg model "$MODEL" --arg sys "$SYSTEM_CONTRACT" --rawfile prompt "$PROMPT_FILE" \
              '{ model:$model, temperature:0, max_tokens:4096,
                 messages:[ {role:"system",content:$sys}, {role:"user",content:$prompt} ] }' > ai/request.json
            ENDPOINT="${BASE%/}/v1/chat/completions"
          fi

          resp_with_code="$(mktemp)"
          curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
               -w "\n%{http_code}\n" -d @ai/request.json "$ENDPOINT" \
            | tee "$resp_with_code" >/dev/null
          status="$(tail -n1 "$resp_with_code")"
          head -n -1 "$resp_with_code" > ai/response.json
          rm -f "$resp_with_code"
          [ "$status" -lt 300 ] || { echo "::error::OpenAI error ${status}"; exit 3; }

          # 共通抽出（Responses/Chat どちらにも対応）
          EXTRACT='[
            .output_text,
            ( try(.output
                 | if type=="array" then .
                   else [] end
                 | map( if has("content")
                         then (.content | (if type=="array" then map(.text // .string // .content // "") else . end)
                                      | (if type=="array" then join("") else (. // "") end))
                         else (.text // .content // "") end)
                 | join("")) catch empty ),
            .choices[0].message.content, .choices[0].text
          ] | map(select(type=="string" and . != "")) | .[0] // ""'

          jq -r "$EXTRACT" ai/response.json > ai/out.txt
          # もしコードフェンスで囲まれていたら剥がす
          sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i ai/out.txt || true
          # 先頭の余計な本文を落として diff だけ切り出し
          awk 'f||/^(diff --git|--- a\/)/{f=1; print}' ai/out.txt > "$PATCH_FILE" || true

          # repair（1 回だけ）
          if ! is_patch "$PATCH_FILE"; then
            echo "::warning::first attempt not a unified diff; try repair"
            head -c 15000 ai/out.txt > ai/out.trim.txt || true
            REPAIR_SYS="If the text contains a diff, extract ONLY the diff. Otherwise synthesize a diff that modifies/creates files strictly inside ALLOWED_PATHS; follow LANGUAGE."
            if printf "%s" "$MODEL" | grep -qiE '^gpt-5-codex( |$|-|:)'; then
              jq -n --arg model "$MODEL" --arg sys "$REPAIR_SYS" --rawfile prev ai/out.trim.txt \
                '{ model:$model, max_output_tokens:4096,
                   input:[ {role:"system",content:[{type:"input_text",text:$sys}]},
                           {role:"user",content:[{type:"input_text",text:$prev}]} ] }' > ai/request.repair.json
            else
              jq -n --arg model "$MODEL" --arg sys "$REPAIR_SYS" --rawfile prev ai/out.trim.txt \
                '{ model:$model, temperature:0, max_tokens:2048,
                   messages:[ {role:"system",content:$sys}, {role:"user",content:$prev} ] }' > ai/request.repair.json
            fi
            resp_with_code="$(mktemp)"
            curl -sS -H "Authorization: Bearer ${OPENAI_API_KEY}" -H "Content-Type: application/json" \
                 -w "\n%{http_code}\n" -d @ai/request.repair.json "$ENDPOINT" \
              | tee "$resp_with_code" >/dev/null
            rstatus="$(tail -n1 "$resp_with_code")"
            head -n -1 "$resp_with_code" > ai/response.repair.json
            rm -f "$resp_with_code"
            [ "$rstatus" -lt 300 ] || { echo "::error::repair call error ${rstatus}"; exit 3; }
            jq -r "$EXTRACT" ai/response.repair.json > ai/out.repair.txt
            sed -E -e '1{/^```[a-zA-Z-]*[[:space:]]*$/d;}' -e '${/^```[[:space:]]*$/d;}' -i ai/out.repair.txt || true
            awk 'f||/^(diff --git|--- a\/)/{f=1; print}' ai/out.repair.txt > "$PATCH_FILE" || true
          fi

          # 最終バリデーション
          if ! is_patch "$PATCH_FILE"; then
            echo "::error::model did not return a unified diff"
            exit 4
          fi

          # 仕様に無い generated/app.php を抑止（必要なら他ファイルも同様に）
          if grep -q '^+++ b/generated/app.php$' "$PATCH_FILE"; then
            if ! grep -Fxq 'generated/app.php' ai/allowed_paths.txt; then
              echo "::error::Patch tries to create generated/app.php which is NOT listed in spec ALLOWED_PATHS"
              exit 5
            fi
          fi

          echo "patch prepared"

      - name: "Apply patch to working tree"
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # まずは通常適用、失敗したら --3way で再試行（full 生成なので失敗で止めずに救済）
          if git apply --check "$PATCH_FILE"; then
            git apply --index --whitespace=fix "$PATCH_FILE"
          else
            echo "::warning::git apply check failed; attempting 3-way merge apply"
            git apply --3way --index --whitespace=fix "$PATCH_FILE" || true
          fi

          # ご要望により「変更なしで失敗」の判定はしない（生成のみ）
          git status --porcelain || true

      - name: "Create Pull Request"
        uses: peter-evans/create-pull-request@v6
        with:
          title: "Codex: generate per spec (lang=${{ steps.compose.outputs.LANG_HINT }}, mode=full, model=gpt-5-codex)"
          body: |
            Generated strictly per environment spec (LANGUAGE) and ALLOWED_PATHS.
          branch: "codex/autogen-${{ github.run_id }}"
          base: "main"
          delete-branch: true
          labels: "codex, automation"

      - name: "Upload ai artifacts"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: "ai-artifacts"
          path: |
            ai/prompt.md
            ai/allowed_paths.txt
            ai/request.json
            ai/response.json
            ai/out.txt
            ai/request.repair.json
            ai/response.repair.json
            ai/out.repair.txt
            ai/patch.diff
          if-no-files-found: "ignore"

      - name: "Cleanup ai workspace before finish"
        if: always()
        shell: bash
        run: |
          rm -rf ai || true
