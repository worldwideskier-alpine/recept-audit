name: "Codex Generate (spec-driven)"

on:
  workflow_call:
    inputs:
      mode:
        description: "実行モード: full（全生成） / incremental（差分）"
        required: false
        default: "full"
        type: string
      model:
        description: "OpenAI モデル名（任意）"
        required: false
        default: ""
        type: string
    secrets:
      OPENAI_API_KEY:
        required: true
  workflow_dispatch:
    inputs:
      mode:
        description: "実行モード: full（全生成） / incremental（差分）"
        required: false
        default: "full"
        type: string
      model:
        description: "OpenAI モデル名（任意）"
        required: false
        default: ""
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  generate:
    runs-on: "ubuntu-latest"
    env:
      PROMPT_FILE: "ai/prompt.md"
      COMPOSITE_PROMPT: "ai/prompt.combined.md"
      MISSING_FILE: "ai/missing_deps.txt"
    steps:
      - name: "Checkout"
        uses: "actions/checkout@v4"
        with:
          fetch-depth: 0

      - name: "Preflight"
        shell: "bash"
        run: |
          set -euo pipefail
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          mkdir -p ai

      - name: "Build prompt from specs (auto collect; no heredoc)"
        shell: "bash"
        run: |
          set -euo pipefail
          : > "${COMPOSITE_PROMPT}"

          add() {
            local f="$1"
            [ -f "$f" ] || return 0
            printf '\n\n<!-- file: %s -->\n\n' "$f" >> "${COMPOSITE_PROMPT}"
            cat "$f" >> "${COMPOSITE_PROMPT}"
          }

          # spec 以下のテキスト/構造化ファイルをすべて収集（順序はソート）
          while IFS= read -r -d '' f; do
            add "$f"
          done < <(
            find spec -type f \
              \( -name "*.md" -o -name "*.txt" -o -name "*.yml" -o -name "*.yaml" -o -name "*.json" \) \
              -print0 | sort -z
          )

          # Authoring rules（最小限・言語非依存）
          {
            echo
            echo "<!-- authoring-rules -->"
            echo
            echo "RULES"
            echo "- When code references local files (relative imports), create missing files with minimal but working implementation AND tests."
            echo "- Do not modify files under 'spec/'."
            echo "- Place tests under 'tests/'. Put source under language-idiomatic directories (e.g. 'src/')."
            echo "- Produce runnable, cohesive changes."
          } >> "${COMPOSITE_PROMPT}"

          cp "${COMPOSITE_PROMPT}" "${PROMPT_FILE}"

      - name: "Scan repository for missing local dependencies (multi-lang)"
        id: "scan"
        shell: "bash"
        run: |
          set -euo pipefail
          mkdir -p ai
          OUT="${MISSING_FILE}"
          : > "${OUT}"

          add_missing () {
            local ref="$1"
            local base="${2:-.}"
            local found="no"
            for p in "$ref" "${ref#./}"; do
              if [ -f "${base}/${p}" ]; then found="yes"; break; fi
            done
            if [ "${found}" = "no" ]; then
              printf '%s\n' "${ref}" >> "${OUT}"
            fi
          }

          # PHP: require/include（相対のみ）
          mapfile -t PHPREFS < <(grep -RPho --include='*.php' \
            '(?:require|include)(?:_once)?\s*\(?\s*["'"'"'](\.{1,2}/[^"'"'"']+)["'"'"']\s*\)?' . 2>/dev/null \
            | sed -E "s/.*['\"]([^'\"]+)['\"].*/\1/" | sort -u || true)
          for r in "${PHPREFS[@]:-}"; do add_missing "$r" "."; done

          # JS/TS: import/require/dynamic import（相対のみ）
          mapfile -t JSREFS < <(grep -RPho --include='*.{js,jsx,ts,tsx,mjs,cjs}' \
            '(?:import\s+[^;]*from\s*|require\s*\(|import\s*\()\s*["'"'"'](\.{1,2}/[^"'"'"']+)["'"'"']' . 2>/dev/null \
            | sed -E "s/.*['\"]([^'\"]+)['\"].*/\1/" | sort -u || true)
          for r in "${JSREFS[@]:-}"; do add_missing "$r" "."; done

          # C/C++: #include "local.h"
          mapfile -t CREFS < <(grep -RPho --include='*.{c,cc,cpp,h,hpp}' \
            '#\s*include\s*"([^"]+)"' . 2>/dev/null \
            | sed -E 's/.*"([^"]+)".*/\1/' | sort -u || true)
          for r in "${CREFS[@]:-}"; do add_missing "$r" "."; done

          # Shell: source ./x / . ./x
          mapfile -t SHREFS < <(grep -RPho --include='*.{sh,bash}' \
            '(?:source|\.)\s+(\.{1,2}/[^ \t;#]+)' . 2>/dev/null \
            | sed -E 's/.*\s+(\.{1,2}\/[^ \t;#]+).*/\1/' | sort -u || true)
          for r in "${SHREFS[@]:-}"; do add_missing "$r" "."; done

          # Ruby: require_relative 'x'
          mapfile -t RBREFS < <(grep -RPho --include='*.rb' \
            'require_relative\s*["'"'"']([^"'"'"']+)["'"'"']' . 2>/dev/null \
            | sed -E "s/.*['\"]([^'\"]+)['\"].*/\1/" | sort -u || true)
          for r in "${RBREFS[@]:-}"; do
            if [ -f "$r" ] || [ -f "${r}.rb" ]; then :; else
              printf '%s\n' "$r (or ${r}.rb)" >> "${OUT}"
            fi
          done

          # Python: relative import（from .foo import ...）
          mapfile -t PYREFS < <(grep -RPho --include='*.py' \
            'from\s+(\.[\w\.]+)\s+import' . 2>/dev/null \
            | sed -E 's/.*from\s+(\.[A-Za-z0-9_\.]+)\s+.*/\1/' | sort -u || true)
          for mod in "${PYREFS[@]:-}"; do
            path="${mod//./\/}"; path="${path#./}"
            cand1="${path}/__init__.py"; cand2="${path}.py"
            [ -f "${cand1}" ] || [ -f "${cand2}" ] || printf '%s\n' "$mod (map to ${path}.py or ${path}/__init__.py)" >> "${OUT}"
          done

          COUNT=$(wc -l < "${OUT}" 2>/dev/null || echo "0")
          echo "missing_count=${COUNT}" >> "${GITHUB_OUTPUT}"
          echo "missing_file=${OUT}" >> "${GITHUB_OUTPUT}"

      - name: "Append missing-deps to prompt (if any)"
        if: "${{ steps.scan.outputs.missing_count != '0' }}"
        shell: "bash"
        run: |
          set -euo pipefail
          {
            echo
            echo "### Missing local dependencies (detected by scanner)"
            cat "${MISSING_FILE}"
          } >> "${PROMPT_FILE}"

      - name: "Run Codex (workspace-write)"
        uses: "openai/codex-action@main"
        with:
          openai-api-key: "${{ secrets.OPENAI_API_KEY }}"
          prompt-file: "${{ env.PROMPT_FILE }}"
          model: "${{ inputs.model }}"
          sandbox: "workspace-write"
        continue-on-error: false

      - name: "Show diff summary"
        shell: "bash"
        run: |
          set -euo pipefail
          git status --porcelain=v1 || true
          git --no-pager diff --stat || true

      - name: "Stop if nothing changed"
        shell: "bash"
        run: |
          set -euo pipefail
          if [ -z "$(git status --porcelain=v1)" ]; then
            echo "No changes produced by Codex. Exiting."
            exit 0
          fi

      - name: "Configure git author (bot)"
        shell: "bash"
        run: |
          set -euo pipefail
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          git add -A
          git commit -m "chore(ai): apply Codex changes (spec-driven)"

      - name: "Create Pull Request"
        uses: "peter-evans/create-pull-request@v7"
        with:
          token: "${{ secrets.GITHUB_TOKEN }}"
          branch: "ai/codex/batch-${{ github.run_id }}"
          base: "main"
          title: "AI: Codex updates"
          body: "Automated changes generated by Codex from specs. Includes fixes for missing local dependencies (if any)."
          labels: "ai,codex"
