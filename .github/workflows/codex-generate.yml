name: "Codex Generate (spec-driven)"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "実行モード: full(全生成) / incremental(差分)"
        required: false
        default: "full"
        type: string
      model:
        description: "OpenAI モデル名（任意）"
        required: false
        default: "gpt-5-codex"
        type: string

  workflow_call:
    inputs:
      mode:
        required: false
        type: string
        default: "full"
      model:
        required: false
        type: string
        default: "gpt-5-codex"
    secrets:
      OPENAI_API_KEY:
        required: true

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: "codex-${{ github.ref }}"
  cancel-in-progress: false

jobs:
  generate:
    name: "generate"
    runs-on: "ubuntu-latest"

    env:
      # 仕様書の在処（フォルダ構成は spec_fixed_v3 の想定。無ければワイルドカード収集）
      SPEC_ROOT: "spec"
      PROMPT_FILE: "ai/prompt.md"
      MODE: "${{ inputs.mode }}"
      MODEL_INPUT: "${{ inputs.model }}"
      OPENAI_API_KEY: "${{ secrets.OPENAI_API_KEY }}"
      BRANCH_NAME: "ai/codex/batch-${{ github.run_id }}"
      ALLOW_EMPTY_PR: "false"

    steps:
      - name: "Checkout"
        uses: "actions/checkout@v4"
        with:
          fetch-depth: 0

      - name: "Preflight: API key"
        shell: "bash"
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "::error::OPENAI_API_KEY is missing"
            exit 1
          fi

      - name: "Scaffold working dirs"
        shell: "bash"
        run: |
          set -euo pipefail
          for d in ai tests evidence; do
            [ -d "$d" ] || mkdir -p "$d"
          done

      - name: "Collect spec → build prompt.md"
        shell: "bash"
        run: |
          set -euo pipefail

          PROMPT="${PROMPT_FILE}"
          : > "${PROMPT}"

          add_section () {
            local title="$1"; shift
            printf "# %s\n\n" "${title}" >> "${PROMPT}"
            for f in "$@"; do
              [ -f "$f" ] || continue
              printf "\n---\n" >> "${PROMPT}"
              printf "## file: %s\n\n" "$f" >> "${PROMPT}"
              sed 's/\r$//' "$f" >> "${PROMPT}"
              printf "\n" >> "${PROMPT}"
            done
            printf "\n" >> "${PROMPT}"
          }

          # 既定の並び（存在すれば順に結合。無ければワイルドカードで拾う）
          mapfile -t FOUND_FOUNDATION < <(find "${SPEC_ROOT}/foundation" -type f 2>/dev/null | sort || true)
          mapfile -t FOUND_ENV       < <(find "${SPEC_ROOT}/env-profiles" -type f 2>/dev/null | sort || true)
          mapfile -t FOUND_FEATURES  < <(find "${SPEC_ROOT}/features" -type f 2>/dev/null | sort || true)
          mapfile -t FOUND_TESTS     < <(find "${SPEC_ROOT}/tests" -type f 2>/dev/null | sort || true)

          if [ "${#FOUND_FOUNDATION[@]}" -eq 0 ] && [ "${#FOUND_ENV[@]}" -eq 0 ] && \
             [ "${#FOUND_FEATURES[@]}" -eq 0 ] && [ "${#FOUND_TESTS[@]}" -eq 0 ]; then
            # 何も無い場合は spec/ 配下の全てを対象にする
            mapfile -t ALL < <(find "${SPEC_ROOT}" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yml" -o -name "*.yaml" -o -name "*.json" \) | sort || true)
            add_section "All specs" "${ALL[@]}"
          else
            [ "${#FOUND_FOUNDATION[@]}" -gt 0 ] && add_section "0) foundation" "${FOUND_FOUNDATION[@]}"
            [ "${#FOUND_ENV[@]}"       -gt 0 ] && add_section "1) env-profiles" "${FOUND_ENV[@]}"
            [ "${#FOUND_FEATURES[@]}"  -gt 0 ] && add_section "2) features" "${FOUND_FEATURES[@]}"
            [ "${#FOUND_TESTS[@]}"     -gt 0 ] && add_section "3) tests" "${FOUND_TESTS[@]}"
          fi

          # 生成方針（強制ルール）を最後に追記
          {
            echo ""
            echo "----"
            echo "## Authoring rules (MUST FOLLOW)"
            echo "- Output only a single unified diff (git-compatible) that applies cleanly at the repository root."
            echo "- Create missing files or directories as needed."
            echo "- Put all verifiable tests under 'tests/'."
            echo "- Do NOT modify files under '.git' or '.github'."
            echo "- Keep spec files under 'spec/' untouched."
            echo "- Prefer creating minimal working scaffolds over skipping ambiguous pieces."
            echo "- Patch must be self-contained (no prose, no code fences)."
            echo "- Mode: ${MODE}"
          } >> "${PROMPT}"

          echo "Built prompt at: ${PROMPT}"
          wc -lc "${PROMPT}" || true

      - name: "Run Codex (inline via OpenAI API → unified diff)"
        shell: "bash"
        run: |
          set -euo pipefail

          MODEL="${MODEL_INPUT:-gpt-5-codex}"
          FALLBACK_MODEL="gpt-4.1-mini"
          REQ="ai/request.json"
          RES="ai/response.json"
          PATCH="ai/patch.diff"

          SYSTEM="You are a careful code-generation agent. Read the spec and output ONLY one unified diff patch that applies cleanly at repo root. No prose, no fences. Create missing files. Ensure tests under 'tests/' are updated/added. Avoid touching '.git' or '.github'."

          USER_CONTENT="$(cat "${PROMPT_FILE}")"

          printf '{'                         > "${REQ}"
          printf '"model":"%s",' "${MODEL}" >> "${REQ}"
          printf '"input":[{"role":"system","content":%s},{"role":"user","content":%s}],' \
            "$(jq -Rsa @json <<< "${SYSTEM}")" \
            "$(jq -Rsa @json <<< "${USER_CONTENT}")" >> "${REQ}"
          printf '"temperature":0,'          >> "${REQ}"
          printf '"max_output_tokens":64000' >> "${REQ}"
          printf '}\n'                       >> "${REQ}"

          call_api () {
            local req="$1"; local out="$2"; local endpoint="$3"
            curl -sS -f \
              -H "Authorization: Bearer ${OPENAI_API_KEY}" \
              -H "Content-Type: application/json" \
              -d @"${req}" \
              "https://api.openai.com${endpoint}" > "${out}"
          }

          STATUS=0
          call_api "${REQ}" "${RES}" "/v1/responses" || STATUS=$?

          if [ "${STATUS}" -ne 0 ]; then
            # フォールバック（/v1/chat/completions）
            printf '{'                                > "${REQ}.chat"
            printf '"model":"%s",' "${MODEL}"        >> "${REQ}.chat"
            printf '"messages":[{"role":"system","content":%s},{"role":"user","content":%s}],' \
              "$(jq -Rsa @json <<< "${SYSTEM}")" \
              "$(jq -Rsa @json <<< "${USER_CONTENT}")" >> "${REQ}.chat"
            printf '"temperature":0'                  >> "${REQ}.chat"
            printf '}\n'                              >> "${REQ}.chat"
            if ! call_api "${REQ}.chat" "${RES}" "/v1/chat/completions"; then
              # モデルが存在しない・権限無し等 → フォールバックモデルで再試行
              for M in "${FALLBACK_MODEL}"; do
                printf '{'                                > "${REQ}.chat"
                printf '"model":"%s",' "${M}"            >> "${REQ}.chat"
                printf '"messages":[{"role":"system","content":%s},{"role":"user","content":%s}],' \
                  "$(jq -Rsa @json <<< "${SYSTEM}")" \
                  "$(jq -Rsa @json <<< "${USER_CONTENT}")" >> "${REQ}.chat"
                printf '"temperature":0'                  >> "${REQ}.chat"
                printf '}\n'                              >> "${REQ}.chat"
                if call_api "${REQ}.chat" "${RES}" "/v1/chat/completions"; then
                  MODEL="${M}"
                  break
                fi
              done
            fi
          fi

          OUTPUT_TEXT="$(jq -r '.output_text // .choices[0].message.content // ""' "${RES}")"
          if [ -z "${OUTPUT_TEXT}" ] || [ "${OUTPUT_TEXT}" = "null" ]; then
            echo "::error::OpenAI response did not contain usable text"
            jq . "${RES}" || true
            exit 1
          fi

          CLEANED="$(printf "%s\n" "${OUTPUT_TEXT}" \
            | sed 's/\r$//' \
            | awk 'BEGIN{f=1} /^```/{next} {print}')"

          if printf "%s" "${CLEANED}" | grep -qE '^(diff |--- )'; then
            printf "%s" "${CLEANED}" \
              | awk 'BEGIN{s=0} /^diff |^--- /{s=1} {if(s)print}' > "${PATCH}"
          else
            printf "%s" "${CLEANED}" > "${PATCH}"
          fi

          echo "----- Patch preview (head) -----"
          head -n 120 "${PATCH}" || true
          echo "-------------------------------"

          if ! git apply --index --reject --whitespace=fix "${PATCH}"; then
            echo "::error::Failed to apply patch. See ai/patch.diff"
            exit 1
          fi

      - name: "Show diff summary"
        shell: "bash"
        run: |
          set -euo pipefail
          git status --porcelain=v1 || true
          echo ""
          git diff --stat || true

      - name: "Configure git author"
        shell: "bash"
        run: |
          set -euo pipefail
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name  "github-actions[bot]"

      - name: "Create or update PR"
        uses: "peter-evans/create-pull-request@v6"
        with:
          branch: "${{ env.BRANCH_NAME }}"
          delete-branch: true
          title: "AI: codex update (mode=${{ env.MODE }}, model=${{ env.MODEL_INPUT }})"
          commit-message: "ai: apply codex patch (mode=${{ env.MODE }}, model=${{ env.MODEL_INPUT }})"
          body: |
            Auto-generated by Codex workflow.
            - Mode: `${{ env.MODE }}`
            - Model: `${{ env.MODEL_INPUT }}`
          labels: "codex, automated"
          draft: false
          signoff: false
          add-paths: |
            .
          token: "${{ secrets.GITHUB_TOKEN }}"
