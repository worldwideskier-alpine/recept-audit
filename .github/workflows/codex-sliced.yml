name: "Codex (sliced)"
on:
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: "codex-sliced"
  cancel-in-progress: true

jobs:
  codex:
    name: "codex (sliced)"
    runs-on: ubuntu-24.04

    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        task:
          - "spec/tasks/00_boot.yml"
          - "spec/tasks/11_endpoints_env.yml"
          - "spec/tasks/12_endpoints_redirects.yml"
          - "spec/tasks/10_health.yml"
          - "spec/tasks/20_provider_setup.yml"
          - "spec/tasks/30_imports_cli.yml"
          - "spec/tasks/40_provider_db.yml"
          - "spec/tasks/50_ui_rbac.yml"

    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENAI_MODEL: "gpt-5-codex"
      OPENAI_BASE_URL: ${{ secrets.OPENAI_BASE_URL }}
      ENDPOINT: "https://api.openai.com/v1/responses"

      SPEC_ROOT: "spec"
      PROMPT_FILE: "ai/prompt.md"
      REQUEST_JSON: "ai/request.json"
      RESPONSE_JSON: "ai/response.json"
      OUT_JSON: "ai/out.files.json"
      STAGING_DIR: "codex_out"

      CURL_TIMEOUT: 900
      CURL_RETRIES: 2
      CURL_RETRY_DELAY: 15
      TITLE: "Codex generation prompt"
      MAX_TOKENS: "8192"

    steps:
      - name: "checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          persist-credentials: false
          lfs: false
          submodules: false
          sparse-checkout-cone-mode: true
          set-safe-directory: true

      - name: "install jq/yq/coreutils/python3"
        run: |
          set -euo pipefail
          sudo apt-get update -y
          # yq は必須（assemble で使用）
          sudo apt-get install -y jq yq coreutils python3
          yq --version

      - name: "prepare task vars"
        id: task
        run: |
          set -euo pipefail
          TASK_FILE="${{ matrix.task }}"
          echo "task_file=${TASK_FILE}" >> "$GITHUB_OUTPUT"

      - name: "assemble prompt.md (includes only)"
        run: |
          set -euo pipefail
          mkdir -p "ai"
          : > "$PROMPT_FILE"
          TASK_FILE="${{ steps.task.outputs.task_file }}"

          TITLE_VAL="$TITLE"
          if [ -f "$TASK_FILE" ]; then
            T="$(yq -r '.title // ""' "$TASK_FILE" 2>/dev/null || true)"
            if [ -n "${T:-}" ]; then TITLE_VAL="$T"; fi
          fi

          printf "# %s\n\n" "$TITLE_VAL" >> "$PROMPT_FILE"
          printf "## STRICT RULES\n\n" >> "$PROMPT_FILE"
          printf -- "- Return ONLY JSON (no prose) that matches {\\\"files\\\":[{\\\"path\\\":string,\\\"content\\\":string},...]}.\n" >> "$PROMPT_FILE"
          printf -- "- Implement runnable APPLICATION CODE and TESTS.\n" >> "$PROMPT_FILE"
          printf -- "- Emit at least one code file under \\\"/src\\\" or \\\"/app\\\".\n" >> "$PROMPT_FILE"
          printf -- "- NEVER write under the \\\"ai/\\\" directory.\n\n" >> "$PROMPT_FILE"
          printf "## SPEC CONTENT\n" >> "$PROMPT_FILE"

          # includes only
          if yq -e '.include' "$TASK_FILE" >/dev/null 2>&1; then
            yq -r '.include[]' "$TASK_FILE" | while read -r f; do
              [ -f "$SPEC_ROOT/$f" ] || continue
              printf "\n### %s\n\n" "$f" >> "$PROMPT_FILE"
              sed -e 's/\r$//' "$SPEC_ROOT/$f" | head -n 4000 >> "$PROMPT_FILE"
            done
          fi

      - name: "build ai/request.json"
        run: |
          set -euo pipefail
          ENDPOINT="${ENDPOINT:-${OPENAI_BASE_URL:-https://api.openai.com}/v1/responses}"
          jq -n \
            --arg model "$OPENAI_MODEL" \
            --rawfile prompt "$PROMPT_FILE" \
            --argjson max_out "${MAX_TOKENS:-8192}" '
          {
            model: $model,
            text: {
              format: {
                type: "json_schema",
                name: "emit_files",
                strict: true,
                schema: {
                  type: "object",
                  additionalProperties: false,
                  required: ["files"],
                  properties: {
                    files: {
                      type: "array",
                      minItems: 1,
                      items: {
                        type: "object",
                        additionalProperties: false,
                        required: ["path","content"],
                        properties: {
                          path:    { type: "string", minLength: 1 },
                          content: { type: "string" }
                        }
                      }
                    }
                  }
                }
              }
            },
            input: [
              { role: "system", content: [ { type: "input_text", text: "You are Codex. Output ONLY a JSON object with the exact shape {\\\\\\\"files\\\\\\\":[{\\\\\\\"path\\\\\\\":string,\\\\\\\"content\\\\\\\":string},...]}. No prose, no code fences. Write full, runnable code. No placeholders. Never write inside ai/." } ] },
              { role: "user",   content: [ { type: "input_text", text: ("Implement the SPEC as runnable application code and tests. Return files to write as JSON only.\\n\\n" + $prompt) } ] }
            ],
            max_output_tokens: $max_out
          }' > "$REQUEST_JSON"

      - name: "call OpenAI Responses API"
        run: |
          set -euo pipefail
          ENDPOINT="${ENDPOINT:-${OPENAI_BASE_URL:-https://api.openai.com}/v1/responses}"
          http_code="$(
            curl --fail-with-body -sS \
              --connect-timeout 30 \
              --max-time "${CURL_TIMEOUT}" \
              --retry "${CURL_RETRIES}" \
              --retry-all-errors \
              --retry-delay "${CURL_RETRY_DELAY}" \
              -H "Authorization: Bearer ${OPENAI_API_KEY}" \
              -H "Content-Type: application/json" \
              -d @"$REQUEST_JSON" "$ENDPOINT" \
              -w "%{http_code}" -o "$RESPONSE_JSON" || true
          )"
          http_code="$(echo -n "$http_code" | tr -d '\r\n[:space:]')"
          echo "HTTP_STATUS=${http_code}"

          if [ "$http_code" = "500" ] || [ "$http_code" = "502" ] || [ "$http_code" = "503" ] || [ "$http_code" = "504" ]; then
            echo "::group::response.json (first 120 lines)"; head -n 120 "$RESPONSE_JSON" || true; echo "::endgroup::"
            echo "::notice title=fallback::HTTP ${http_code} detected. Retrying once with max_output_tokens=12288"
            jq '. + {max_output_tokens: 12288}' "$REQUEST_JSON" > ai/request.fallback.json
            http_code_fallback="$(
              curl --fail-with-body -sS \
                --connect-timeout 30 \
                --max-time "${CURL_TIMEOUT}" \
                --retry 0 \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d @ai/request.fallback.json "$ENDPOINT" \
                -w "%{http_code}" -o "$RESPONSE_JSON" || true
            )"
            http_code_fallback="$(echo -n "$http_code_fallback" | tr -d '\r\n[:space:]')"
            echo "HTTP_STATUS_FALLBACK=${http_code_fallback}"
            http_code="${http_code_fallback}"
          fi

          if [ "${http_code}" -lt 200 ] || [ "${http_code}" -ge 400 ]; then
            echo "::error title=OpenAI API returned ${http_code}::See response.json for details"
            echo "::group::response.json (first 120 lines)"; head -n 120 "$RESPONSE_JSON" || true; echo "::endgroup::"
            exit 22
          fi

          echo "::group::response.json (first 80 lines)"; head -n 80 "$RESPONSE_JSON" || true; echo "::endgroup::"

          STATUS="$(jq -r '.status // empty' "$RESPONSE_JSON")"
          if [ "${STATUS}" != "completed" ]; then
            REASON="$(jq -r '.incomplete_details.reason // "unknown"' "$RESPONSE_JSON")"
            echo "::error title=OpenAI response incomplete::status=${STATUS}, reason=${REASON}"
            echo "::group::response.json (first 200 lines)"; head -n 200 "$RESPONSE_JSON" || true; echo "::endgroup::"
            exit 22
          fi

      - name: "extract model JSON and write files"
        run: |
          set -euo pipefail
          mkdir -p "$STAGING_DIR"
          jq -e -r '
            .output_text
            // ( [ .output[]? .content[]? | select(.type=="output_text") | .text ] | .[0] )
            // ( [ .output[]? .content[]? | select(.type=="text")        | .text ] | .[0] )
          ' "$RESPONSE_JSON" > ai/out.raw.txt
          jq -e . ai/out.raw.txt > "$OUT_JSON"
          jq -e 'type=="object" and has("files") and (.files|type=="array") and (.files|length>0)' "$OUT_JSON" >/dev/null

          i=0
          jq -c '.files[]' "$OUT_JSON" | while read -r row; do
            path=$(printf '%s' "$row" | jq -r '.path')
            content=$(printf '%s' "$row" | jq -r '.content')
            case "$path" in
              ai/*|./ai/*) echo "::warning title=skipped forbidden path::$path"; continue;;
            esac
            mkdir -p "$(dirname "$path")" "$(dirname "$STAGING_DIR/$path")"
            printf '%s' "$content" > "$path"
            printf '%s' "$content" > "$STAGING_DIR/$path"
            echo "wrote $path"; i=$((i+1))
          done
          if [ "$i" -eq 0 ]; then
            echo "::error title=no files emitted::Model returned zero writable files"
            exit 1
          fi

      - name: "upload artifact (codex_out)"
        uses: actions/upload-artifact@v4
        with:
          name: "codex_out"
          path: "${{ env.STAGING_DIR }}"
          if-no-files-found: "error"
